{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar ParserError = /*#__PURE__*/function (_Error) {\n  _inherits(ParserError, _Error);\n\n  var _super = _createSuper(ParserError);\n\n  function ParserError(start, end, type, values) {\n    var _this;\n\n    _classCallCheck(this, ParserError);\n\n    _this = _super.call(this, \"Internal \".concat(type, \" parse error\"));\n\n    _defineProperty(_assertThisInitialized(_this), \"start\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"end\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"values\", void 0);\n\n    _this.type = type;\n    _this.start = start;\n    _this.end = end;\n    _this.values = values;\n    return _this;\n  }\n\n  _createClass(ParserError, [{\n    key: \"getParserError\",\n    value: function getParserError(equation) {\n      return _objectSpread2({\n        type: 'parser-error',\n        errorType: this.type,\n        start: this.start,\n        end: this.end,\n        equation: equation\n      }, this.values);\n    }\n  }]);\n\n  return ParserError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // Operators type map\n\n\nvar operatorMap = {\n  '=': 'equals',\n  '<': 'less-than',\n  '>': 'greater-than',\n  '≤': 'less-than-equals',\n  '≥': 'greater-than-equals',\n  '≈': 'approximates',\n  '+': 'plus',\n  '-': 'minus',\n  '−': 'minus',\n  // Minus Sign (U+2212)\n  '±': 'plus-minus',\n  ' ': 'multiply-implicit',\n  '*': 'multiply-dot',\n  '∗': 'multiply-dot',\n  // Asterisk Operator (U+2217)\n  '⋅': 'multiply-dot',\n  // Dot Operator (U+22C5)\n  '×': 'multiply-cross',\n  // Multiplication Sign (U+00D7)\n  '✕': 'multiply-cross',\n  // Multiplication X (U+2715)\n  '/': 'divide-fraction',\n  '∕': 'divide-fraction',\n  // Division Slash (U+2215)\n  '÷': 'divide-inline',\n  // Division Sign (U+00F7)\n  '^': 'power',\n  '?': 'operator-placeholder'\n};\nvar isWhitespace = /\\s/;\nvar isCharNumber = /[0-9.]/; // Leading numbers doesn't matter, since number check is before name check\n\nvar isCharName = /[0-9A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u01BF\\u0391-\\u03c9'\"%‰°_∞]/;\nvar isValidNumber = /^([0-9]+|\\.[0-9]+|[0-9]+\\.[0-9]+)$/;\n\nfunction endOfPattern(input, pattern, start) {\n  var end = start;\n\n  do {\n    end++;\n  } while (end < input.length && pattern.test(input[end]));\n\n  return end;\n}\n\nvar tokenize = function tokenize(input) {\n  var result = [];\n  var lastType = null;\n\n  for (var i = 0; i < input.length; i++) {\n    var current = input[i];\n\n    if (isWhitespace.test(current)) {\n      continue;\n    } else if (isCharNumber.test(current)) {\n      var end = endOfPattern(input, isCharNumber, i);\n\n      if (lastType === 'number') {\n        throw new ParserError(result[result.length - 1].position, end - 1, 'numberWhitespace', {});\n      }\n\n      if (lastType === 'name' || lastType === 'parens-close' || lastType === 'matrix-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      var value = input.substring(i, end);\n\n      if (!isValidNumber.test(value)) {\n        throw new ParserError(i, end - 1, 'invalidNumber', {});\n      }\n\n      result.push({\n        type: 'number',\n        value: value,\n        position: i\n      });\n      i = end - 1;\n    } else if (isCharName.test(current)) {\n      if (lastType === 'number' || lastType === 'name' || lastType === 'parens-close' || lastType === 'matrix-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      var _end = endOfPattern(input, isCharName, i);\n\n      result.push({\n        type: 'name',\n        value: input.substring(i, _end),\n        position: i\n      });\n      i = _end - 1;\n    } else if (current in operatorMap) {\n      if (lastType === 'operator') {\n        throw new ParserError(i - 1, i, 'adjecentOperator', {});\n      }\n\n      result.push({\n        type: 'operator',\n        value: operatorMap[current],\n        symbol: current,\n        position: i\n      });\n    } else if (current === '(') {\n      if (lastType === 'number' || lastType === 'parens-close' || lastType === 'matrix-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      result.push({\n        type: 'parens-open',\n        position: i\n      });\n    } else if (current === ')') {\n      result.push({\n        type: 'parens-close',\n        position: i\n      });\n    } else if (current === '[') {\n      if (lastType === 'number' || lastType === 'name' || lastType === 'parens-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      result.push({\n        type: 'matrix-open',\n        position: i\n      });\n    } else if (current === ']') {\n      result.push({\n        type: 'matrix-close',\n        position: i\n      });\n    } else if (current === ',') {\n      result.push({\n        type: 'comma',\n        position: i\n      });\n    } else {\n      throw new ParserError(i, i, 'invalidChar', {\n        character: current\n      });\n    }\n\n    lastType = result[result.length - 1].type;\n  }\n\n  return result;\n};\n/**\n * Compiler-error and runtime-error on unhandled type\n *\n * @param typed: Object with type-property\n * @param getMessage: get an error message for runtime errors\n */\n\n\nfunction throwUnknownType(typed, getMessage) {\n  throw new Error(getMessage(typed && typed.type || 'unknown'));\n}\n\nvar precedence = {\n  'equals': 1,\n  'less-than': 1,\n  'greater-than': 1,\n  'less-than-equals': 1,\n  'greater-than-equals': 1,\n  'approximates': 1,\n  'plus': 2,\n  'minus': 2,\n  'plus-minus': 2,\n  'multiply-implicit': 3,\n  'multiply-dot': 3,\n  'multiply-cross': 3,\n  'divide-fraction': 3,\n  'divide-inline': 3,\n  'power': 4,\n  'operator-placeholder': 5\n};\nvar unaryOperatorMap = {\n  'plus': 'positive',\n  'minus': 'negative',\n  'plus-minus': 'positive-negative',\n  'operator-placeholder': 'operator-unary-placeholder'\n};\nvar rightAssociativeOperators = ['power'];\n\nvar parseListExpression = function parseListExpression(input, tokens, startAt) {\n  var results = [];\n  var subexpression;\n  var i = startAt;\n\n  do {\n    subexpression = parseSubexpression(input, tokens, i);\n\n    if (subexpression.result) {\n      results.push(subexpression.result);\n    }\n\n    i = subexpression.last + 1;\n  } while (subexpression.terminator === 'comma');\n\n  return {\n    results: results,\n    terminator: subexpression.terminator,\n    last: subexpression.last\n  };\n};\n\nvar parseSubexpression = function parseSubexpression(input, tokens, startAt) {\n  var output = [];\n  var operators = [];\n\n  var getTokenType = function getTokenType(index) {\n    return tokens[index] ? tokens[index].type : undefined;\n  };\n\n  var getTokenPosition = function getTokenPosition(index) {\n    return tokens[index] && tokens[index].position;\n  };\n\n  var addOperator = function addOperator(operator) {\n    var b = output.pop();\n    var a = output.pop();\n    var unaryType = unaryOperatorMap[operator.value];\n\n    if (a && b) {\n      output.push({\n        type: operator.value,\n        a: a,\n        b: b\n      });\n    } else if (unaryType && b) {\n      output.push({\n        type: unaryType,\n        value: b\n      });\n    } else if (b) {\n      throw new ParserError(operator.position, operator.position, 'invalidUnary', {\n        symbol: operator.symbol\n      });\n    } else {\n      // No operands. This should never happen, all cases should be caught by operatorLast instead\n      throw new Error('Unexpected parser state, operator with no operands');\n    }\n  };\n\n  var prepareResult = function prepareResult(terminator, last) {\n    if (tokens[last - 1].type === 'operator') {\n      throw new ParserError(getTokenPosition(last - 1), getTokenPosition(last - 1), 'operatorLast', {});\n    }\n\n    while (operators.length > 0) {\n      addOperator(operators.pop());\n    }\n\n    if (output.length > 1) {\n      throw new ParserError(getTokenPosition(startAt), getTokenPosition(last - 1), 'multipleExpressions', {});\n    }\n\n    if (output.length === 0) {\n      return {\n        result: null,\n        terminator: terminator,\n        last: last\n      };\n    }\n\n    return {\n      result: output[0],\n      terminator: terminator,\n      last: last\n    };\n  };\n\n  for (var i = startAt; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    switch (token.type) {\n      case 'number':\n        output.push({\n          type: 'number',\n          value: token.value\n        });\n        break;\n\n      case 'name':\n        if (getTokenType(i + 1) === 'parens-open') {\n          // Function\n          var _parseListExpression = parseListExpression(input, tokens, i + 2),\n              results = _parseListExpression.results,\n              last = _parseListExpression.last,\n              terminator = _parseListExpression.terminator;\n\n          if (terminator !== 'parens-close') {\n            throw new ParserError(getTokenPosition(i + 1), getTokenPosition(last - 1), 'expectedCloseParens', {});\n          }\n\n          if (token.value === '_') {\n            output.push({\n              type: 'function-placeholder',\n              args: results\n            });\n          } else {\n            output.push({\n              type: 'function',\n              name: token.value,\n              args: results\n            });\n          }\n\n          i = last;\n        } else if (token.value === '_') {\n          output.push({\n            type: 'operand-placeholder'\n          });\n        } else {\n          // Variable\n          output.push({\n            type: 'variable',\n            name: token.value\n          });\n        }\n\n        break;\n\n      case 'matrix-open':\n        if (getTokenType(i + 1) === 'matrix-open') {\n          // Parsing matrix\n          // [[a,b,c][d,e,f][g,h,i]]\n          var values = []; // Extract all nested vectors\n\n          var current = i + 1;\n\n          while (getTokenType(current) === 'matrix-open') {\n            var _parseListExpression2 = parseListExpression(input, tokens, current + 1),\n                _results = _parseListExpression2.results,\n                _last = _parseListExpression2.last,\n                _terminator = _parseListExpression2.terminator;\n\n            if (_terminator !== 'matrix-close') {\n              throw new ParserError(getTokenPosition(current), getTokenPosition(_last - 1), 'expectedSquareBracket', {});\n            }\n\n            if (values.length > 0 && values[0].length !== _results.length) {\n              throw new ParserError(getTokenPosition(current), getTokenPosition(_last), 'matrixMixedDimension', {\n                lengthExpected: values[0].length,\n                lengthReceived: _results.length\n              });\n            }\n\n            if (_results.length === 0) {\n              throw new ParserError(getTokenPosition(current), getTokenPosition(_last), 'matrixEmpty', {});\n            }\n\n            values.push(_results);\n            current = _last + 1;\n          } // The last vector-component should be followed by a closing bracket\n\n\n          if (getTokenType(current) !== 'matrix-close') {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(current - 1), 'expectedSquareBracket', {});\n          }\n\n          output.push({\n            type: 'matrix',\n            n: values[0].length,\n            m: values.length,\n            values: values\n          }); // Advance parsing past closing bracket\n\n          i = current;\n        } else {\n          // Parsing single vector\n          // [a,b,c]\n          var _parseListExpression3 = parseListExpression(input, tokens, i + 1),\n              _results2 = _parseListExpression3.results,\n              _last2 = _parseListExpression3.last,\n              _terminator2 = _parseListExpression3.terminator;\n\n          if (_terminator2 !== 'matrix-close') {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last2 - 1), 'expectedSquareBracket', {});\n          }\n\n          if (_results2.length === 0) {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last2), 'vectorEmpty', {});\n          }\n\n          output.push({\n            type: 'matrix',\n            n: 1,\n            m: _results2.length,\n            values: _results2.map(function (value) {\n              return [value];\n            })\n          });\n          i = _last2;\n        }\n\n        break;\n\n      case 'parens-open':\n        {\n          var _parseSubexpression = parseSubexpression(input, tokens, i + 1),\n              result = _parseSubexpression.result,\n              _last3 = _parseSubexpression.last,\n              _terminator3 = _parseSubexpression.terminator;\n\n          if (_terminator3 !== 'parens-close') {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last3 - 1), 'expectedCloseParens', {});\n          }\n\n          if (result === null) {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last3), 'emptyBlock', {});\n          }\n\n          output.push({\n            type: 'block',\n            child: result\n          });\n          i = _last3;\n          break;\n        }\n\n      case 'operator':\n        while (operators.length > 0) {\n          var other = operators[operators.length - 1];\n          var tokenPrecedence = precedence[token.value];\n          var otherPrecedence = precedence[other.value];\n\n          if (otherPrecedence < tokenPrecedence || rightAssociativeOperators.includes(other.value) && otherPrecedence === tokenPrecedence) {\n            break;\n          }\n\n          operators.pop();\n          addOperator(other);\n        }\n\n        operators.push(token);\n        break;\n\n      case 'comma':\n      case 'parens-close':\n      case 'matrix-close':\n        return prepareResult(token.type, i);\n\n      default:\n        throwUnknownType(token, function (type) {\n          return \"Equation render: cannot resolve type \\\"\".concat(type, \"\\\"\");\n        });\n    }\n  }\n\n  return prepareResult('end', tokens.length);\n};\n\nvar parse = function parse(input) {\n  try {\n    var tokens = tokenize(input);\n\n    var _parseSubexpression = parseSubexpression(input, tokens, 0),\n        result = _parseSubexpression.result,\n        last = _parseSubexpression.last,\n        terminator = _parseSubexpression.terminator;\n\n    if (terminator !== 'end') {\n      throw new ParserError(tokens[last].position, tokens[last].position, 'expectedEnd', {});\n    }\n\n    if (result === null) {\n      throw new ParserError(0, 0, 'expectedEnd', {});\n    }\n\n    return result;\n  } catch (error) {\n    if (error instanceof ParserError) {\n      return error.getParserError(input);\n    } else {\n      throw error;\n    }\n  }\n};\n\nvar renderTree = function renderTree(tree) {\n  if (tree.type === 'parser-error') {\n    return \"\".concat(tree.errorType, \" error\\n  \").concat(tree.equation, \"\\n  \").concat(''.padStart(tree.start, ' ').padEnd(tree.end + 1, '^'));\n  }\n\n  return pushTree(tree).join('\\n');\n};\n\nvar operatorMap$1 = {\n  'equals': '=',\n  'less-than': '<',\n  'greater-than': '>',\n  'less-than-equals': '≤',\n  'greater-than-equals': '≥',\n  'approximates': '≈',\n  'plus': '+',\n  'minus': '-',\n  'plus-minus': '±',\n  'multiply-implicit': '*',\n  'multiply-dot': '*',\n  'multiply-cross': '×',\n  'divide-fraction': '/',\n  'divide-inline': '÷',\n  'power': '^',\n  'operator-placeholder': '?'\n};\nvar unaryOperatorMap$1 = {\n  'positive': '+',\n  'negative': '-',\n  'positive-negative': '±',\n  'operator-unary-placeholder': '?'\n};\n\nfunction pushTree(tree) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var indentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'initial';\n  var ownIndent = indent;\n  var descendantIndent = indent;\n\n  switch (indentType) {\n    case 'regular':\n      ownIndent += '├─ ';\n      descendantIndent += '│  ';\n      break;\n\n    case 'last':\n      ownIndent += '└─ ';\n      descendantIndent += '   ';\n      break;\n  }\n\n  switch (tree.type) {\n    case 'number':\n      buffer.push(ownIndent + tree.value);\n      break;\n\n    case 'variable':\n      buffer.push(\"\".concat(ownIndent, \"\\\"\").concat(tree.name, \"\\\"\"));\n      break;\n\n    case 'positive':\n    case 'negative':\n    case 'positive-negative':\n    case 'operator-unary-placeholder':\n      buffer.push(ownIndent + unaryOperatorMap$1[tree.type]);\n      pushTree(tree.value, buffer, descendantIndent, 'last');\n      break;\n\n    case 'block':\n      buffer.push(\"\".concat(ownIndent, \"()\"));\n      pushTree(tree.child, buffer, descendantIndent, 'last');\n      break;\n\n    case 'equals':\n    case 'less-than':\n    case 'greater-than':\n    case 'less-than-equals':\n    case 'greater-than-equals':\n    case 'approximates':\n    case 'plus':\n    case 'minus':\n    case 'plus-minus':\n    case 'multiply-implicit':\n    case 'multiply-dot':\n    case 'multiply-cross':\n    case 'divide-fraction':\n    case 'divide-inline':\n    case 'power':\n    case 'operator-placeholder':\n      buffer.push(ownIndent + operatorMap$1[tree.type]);\n      pushTree(tree.a, buffer, descendantIndent, 'regular');\n      pushTree(tree.b, buffer, descendantIndent, 'last');\n      break;\n\n    case 'function':\n      buffer.push(\"\".concat(ownIndent).concat(tree.name, \"()\"));\n      tree.args.forEach(function (arg, idx) {\n        pushTree(arg, buffer, descendantIndent, idx < tree.args.length - 1 ? 'regular' : 'last');\n      });\n      break;\n\n    case 'function-placeholder':\n      buffer.push(\"\".concat(ownIndent, \"<placeholder>()\"));\n      tree.args.forEach(function (arg, idx) {\n        pushTree(arg, buffer, descendantIndent, idx < tree.args.length - 1 ? 'regular' : 'last');\n      });\n      break;\n\n    case 'matrix':\n      if (tree.n === 1) {\n        buffer.push(\"\".concat(ownIndent, \"v \").concat(tree.m));\n        tree.values.forEach(function (row, idx) {\n          pushTree(row[0], buffer, descendantIndent, idx < tree.m - 1 ? 'regular' : 'last');\n        });\n      } else {\n        buffer.push(\"\".concat(ownIndent, \"m \").concat(tree.m, \"x\").concat(tree.n));\n        tree.values.forEach(function (row, rowIdx) {\n          var rowIndent = descendantIndent + (rowIdx < tree.m - 1 ? '│  ' : '   ');\n          row.forEach(function (cell, cellIdx) {\n            if (cellIdx === 0) {\n              if (rowIdx < tree.m - 1) {\n                pushTree(cell, buffer, descendantIndent + '├──┬─ ', 'initial');\n              } else {\n                pushTree(cell, buffer, descendantIndent + '└──┬─ ', 'initial');\n              }\n            } else {\n              pushTree(cell, buffer, rowIndent, cellIdx < tree.n - 1 ? 'regular' : 'last');\n            }\n          });\n        });\n      }\n\n      break;\n\n    case 'operand-placeholder':\n      buffer.push(\"\".concat(ownIndent, \"<placeholder>\"));\n      break;\n\n    default:\n      throwUnknownType(tree, function (type) {\n        return \"Equation tree to string: cannot resolve type \\\"\".concat(type, \"\\\"\");\n      });\n  }\n\n  return buffer;\n}\n\nvar stringify = function stringify(tree) {\n  if (tree.type === 'parser-error') {\n    return tree.equation;\n  }\n\n  var buffer = [];\n  stringifyTree(tree, buffer);\n  return buffer.join('');\n};\n\nvar operatorMap$2 = {\n  'equals': ' = ',\n  'less-than': ' < ',\n  'greater-than': ' > ',\n  'less-than-equals': ' ≤ ',\n  'greater-than-equals': ' ≥ ',\n  'approximates': ' ≈ ',\n  'plus': ' + ',\n  'minus': ' - ',\n  'plus-minus': ' ± ',\n  'multiply-implicit': ' ',\n  'multiply-dot': ' * ',\n  'multiply-cross': ' × ',\n  'divide-fraction': ' / ',\n  'divide-inline': ' ÷ ',\n  'power': ' ^ ',\n  'operator-placeholder': ' ? '\n};\nvar unaryOperatorMap$2 = {\n  'positive': '+',\n  'negative': '-',\n  'positive-negative': '±',\n  'operator-unary-placeholder': '?'\n};\n\nfunction stringifyTree(tree, buffer) {\n  switch (tree.type) {\n    case 'number':\n      buffer.push(tree.value.toString());\n      break;\n\n    case 'variable':\n      buffer.push(tree.name);\n      break;\n\n    case 'positive':\n    case 'negative':\n    case 'positive-negative':\n    case 'operator-unary-placeholder':\n      buffer.push(unaryOperatorMap$2[tree.type]);\n      stringifyTree(tree.value, buffer);\n      break;\n\n    case 'block':\n      buffer.push('(');\n      stringifyTree(tree.child, buffer);\n      buffer.push(')');\n      break;\n\n    case 'plus':\n    case 'minus':\n    case 'plus-minus':\n    case 'divide-fraction':\n    case 'divide-inline':\n    case 'multiply-implicit':\n    case 'multiply-dot':\n    case 'multiply-cross':\n    case 'power':\n    case 'equals':\n    case 'less-than':\n    case 'greater-than':\n    case 'less-than-equals':\n    case 'greater-than-equals':\n    case 'approximates':\n    case 'operator-placeholder':\n      stringifyTree(tree.a, buffer);\n      buffer.push(operatorMap$2[tree.type]);\n      stringifyTree(tree.b, buffer);\n      break;\n\n    case 'function':\n    case 'function-placeholder':\n      buffer.push(tree.type === 'function' ? tree.name : '_');\n      buffer.push('(');\n      tree.args.forEach(function (arg, idx) {\n        if (idx > 0) {\n          buffer.push(',');\n        }\n\n        stringifyTree(arg, buffer);\n      });\n      buffer.push(')');\n      break;\n\n    case 'matrix':\n      buffer.push('[');\n      tree.values.forEach(function (row, rowIdx) {\n        if (tree.n > 1) {\n          buffer.push('[');\n        } else if (rowIdx > 0) {\n          buffer.push(',');\n        }\n\n        row.forEach(function (cell, cellIdx) {\n          if (cellIdx > 0) {\n            buffer.push(',');\n          }\n\n          stringifyTree(cell, buffer);\n        });\n\n        if (tree.n > 1) {\n          buffer.push(']');\n        }\n      });\n      buffer.push(']');\n      break;\n\n    case 'operand-placeholder':\n      buffer.push('_');\n      break;\n\n    default:\n      throwUnknownType(tree, function (type) {\n        return \"Equation tree to string: cannot resolve type \\\"\".concat(type, \"\\\"\");\n      });\n  }\n}\n\nexport { parse, renderTree, stringify };","map":{"version":3,"sources":["C:/Users/dell/Documents/ITT/MetodoBiseccionWebApp/frontend/node_modules/equation-parser/dist/index.esm.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_inherits","subClass","superClass","create","constructor","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","call","e","_construct","Parent","args","Class","a","Function","bind","_isNativeFunction","fn","indexOf","_wrapNativeSuper","_cache","Map","undefined","has","get","set","Wrapper","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","ParserError","_Error","_super","start","end","type","values","_this","concat","getParserError","equation","errorType","Error","operatorMap","isWhitespace","isCharNumber","isCharName","isValidNumber","endOfPattern","input","pattern","test","tokenize","lastType","current","position","symbol","substring","_end","character","throwUnknownType","typed","getMessage","precedence","unaryOperatorMap","rightAssociativeOperators","parseListExpression","tokens","startAt","results","subexpression","parseSubexpression","last","terminator","output","operators","getTokenType","index","getTokenPosition","addOperator","operator","b","pop","unaryType","prepareResult","token","_parseListExpression","name","_parseListExpression2","_results","_last","_terminator","lengthExpected","lengthReceived","n","m","_parseListExpression3","_results2","_last2","_terminator2","map","_parseSubexpression","_last3","_terminator3","child","other","tokenPrecedence","otherPrecedence","includes","parse","error","renderTree","tree","padStart","padEnd","pushTree","join","operatorMap$1","unaryOperatorMap$1","buffer","indent","indentType","ownIndent","descendantIndent","arg","idx","row","rowIdx","rowIndent","cell","cellIdx","stringify","stringifyTree","operatorMap$2","unaryOperatorMap$2"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar ParserError = /*#__PURE__*/function (_Error) {\n  _inherits(ParserError, _Error);\n\n  var _super = _createSuper(ParserError);\n\n  function ParserError(start, end, type, values) {\n    var _this;\n\n    _classCallCheck(this, ParserError);\n\n    _this = _super.call(this, \"Internal \".concat(type, \" parse error\"));\n\n    _defineProperty(_assertThisInitialized(_this), \"start\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"end\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"values\", void 0);\n\n    _this.type = type;\n    _this.start = start;\n    _this.end = end;\n    _this.values = values;\n    return _this;\n  }\n\n  _createClass(ParserError, [{\n    key: \"getParserError\",\n    value: function getParserError(equation) {\n      return _objectSpread2({\n        type: 'parser-error',\n        errorType: this.type,\n        start: this.start,\n        end: this.end,\n        equation: equation\n      }, this.values);\n    }\n  }]);\n\n  return ParserError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n// Operators type map\nvar operatorMap = {\n  '=': 'equals',\n  '<': 'less-than',\n  '>': 'greater-than',\n  '≤': 'less-than-equals',\n  '≥': 'greater-than-equals',\n  '≈': 'approximates',\n  '+': 'plus',\n  '-': 'minus',\n  '−': 'minus',\n  // Minus Sign (U+2212)\n  '±': 'plus-minus',\n  ' ': 'multiply-implicit',\n  '*': 'multiply-dot',\n  '∗': 'multiply-dot',\n  // Asterisk Operator (U+2217)\n  '⋅': 'multiply-dot',\n  // Dot Operator (U+22C5)\n  '×': 'multiply-cross',\n  // Multiplication Sign (U+00D7)\n  '✕': 'multiply-cross',\n  // Multiplication X (U+2715)\n  '/': 'divide-fraction',\n  '∕': 'divide-fraction',\n  // Division Slash (U+2215)\n  '÷': 'divide-inline',\n  // Division Sign (U+00F7)\n  '^': 'power',\n  '?': 'operator-placeholder'\n};\n\nvar isWhitespace = /\\s/;\nvar isCharNumber = /[0-9.]/; // Leading numbers doesn't matter, since number check is before name check\n\nvar isCharName = /[0-9A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u01BF\\u0391-\\u03c9'\"%‰°_∞]/;\nvar isValidNumber = /^([0-9]+|\\.[0-9]+|[0-9]+\\.[0-9]+)$/;\n\nfunction endOfPattern(input, pattern, start) {\n  var end = start;\n\n  do {\n    end++;\n  } while (end < input.length && pattern.test(input[end]));\n\n  return end;\n}\n\nvar tokenize = function tokenize(input) {\n  var result = [];\n  var lastType = null;\n\n  for (var i = 0; i < input.length; i++) {\n    var current = input[i];\n\n    if (isWhitespace.test(current)) {\n      continue;\n    } else if (isCharNumber.test(current)) {\n      var end = endOfPattern(input, isCharNumber, i);\n\n      if (lastType === 'number') {\n        throw new ParserError(result[result.length - 1].position, end - 1, 'numberWhitespace', {});\n      }\n\n      if (lastType === 'name' || lastType === 'parens-close' || lastType === 'matrix-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      var value = input.substring(i, end);\n\n      if (!isValidNumber.test(value)) {\n        throw new ParserError(i, end - 1, 'invalidNumber', {});\n      }\n\n      result.push({\n        type: 'number',\n        value: value,\n        position: i\n      });\n      i = end - 1;\n    } else if (isCharName.test(current)) {\n      if (lastType === 'number' || lastType === 'name' || lastType === 'parens-close' || lastType === 'matrix-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      var _end = endOfPattern(input, isCharName, i);\n\n      result.push({\n        type: 'name',\n        value: input.substring(i, _end),\n        position: i\n      });\n      i = _end - 1;\n    } else if (current in operatorMap) {\n      if (lastType === 'operator') {\n        throw new ParserError(i - 1, i, 'adjecentOperator', {});\n      }\n\n      result.push({\n        type: 'operator',\n        value: operatorMap[current],\n        symbol: current,\n        position: i\n      });\n    } else if (current === '(') {\n      if (lastType === 'number' || lastType === 'parens-close' || lastType === 'matrix-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      result.push({\n        type: 'parens-open',\n        position: i\n      });\n    } else if (current === ')') {\n      result.push({\n        type: 'parens-close',\n        position: i\n      });\n    } else if (current === '[') {\n      if (lastType === 'number' || lastType === 'name' || lastType === 'parens-close') {\n        result.push({\n          type: 'operator',\n          value: 'multiply-implicit',\n          symbol: ' ',\n          position: i\n        });\n      }\n\n      result.push({\n        type: 'matrix-open',\n        position: i\n      });\n    } else if (current === ']') {\n      result.push({\n        type: 'matrix-close',\n        position: i\n      });\n    } else if (current === ',') {\n      result.push({\n        type: 'comma',\n        position: i\n      });\n    } else {\n      throw new ParserError(i, i, 'invalidChar', {\n        character: current\n      });\n    }\n\n    lastType = result[result.length - 1].type;\n  }\n\n  return result;\n};\n\n/**\n * Compiler-error and runtime-error on unhandled type\n *\n * @param typed: Object with type-property\n * @param getMessage: get an error message for runtime errors\n */\nfunction throwUnknownType(typed, getMessage) {\n  throw new Error(getMessage(typed && typed.type || 'unknown'));\n}\n\nvar precedence = {\n  'equals': 1,\n  'less-than': 1,\n  'greater-than': 1,\n  'less-than-equals': 1,\n  'greater-than-equals': 1,\n  'approximates': 1,\n  'plus': 2,\n  'minus': 2,\n  'plus-minus': 2,\n  'multiply-implicit': 3,\n  'multiply-dot': 3,\n  'multiply-cross': 3,\n  'divide-fraction': 3,\n  'divide-inline': 3,\n  'power': 4,\n  'operator-placeholder': 5\n};\nvar unaryOperatorMap = {\n  'plus': 'positive',\n  'minus': 'negative',\n  'plus-minus': 'positive-negative',\n  'operator-placeholder': 'operator-unary-placeholder'\n};\nvar rightAssociativeOperators = ['power'];\nvar parseListExpression = function parseListExpression(input, tokens, startAt) {\n  var results = [];\n  var subexpression;\n  var i = startAt;\n\n  do {\n    subexpression = parseSubexpression(input, tokens, i);\n\n    if (subexpression.result) {\n      results.push(subexpression.result);\n    }\n\n    i = subexpression.last + 1;\n  } while (subexpression.terminator === 'comma');\n\n  return {\n    results: results,\n    terminator: subexpression.terminator,\n    last: subexpression.last\n  };\n};\nvar parseSubexpression = function parseSubexpression(input, tokens, startAt) {\n  var output = [];\n  var operators = [];\n\n  var getTokenType = function getTokenType(index) {\n    return tokens[index] ? tokens[index].type : undefined;\n  };\n\n  var getTokenPosition = function getTokenPosition(index) {\n    return tokens[index] && tokens[index].position;\n  };\n\n  var addOperator = function addOperator(operator) {\n    var b = output.pop();\n    var a = output.pop();\n    var unaryType = unaryOperatorMap[operator.value];\n\n    if (a && b) {\n      output.push({\n        type: operator.value,\n        a: a,\n        b: b\n      });\n    } else if (unaryType && b) {\n      output.push({\n        type: unaryType,\n        value: b\n      });\n    } else if (b) {\n      throw new ParserError(operator.position, operator.position, 'invalidUnary', {\n        symbol: operator.symbol\n      });\n    } else {\n      // No operands. This should never happen, all cases should be caught by operatorLast instead\n      throw new Error('Unexpected parser state, operator with no operands');\n    }\n  };\n\n  var prepareResult = function prepareResult(terminator, last) {\n    if (tokens[last - 1].type === 'operator') {\n      throw new ParserError(getTokenPosition(last - 1), getTokenPosition(last - 1), 'operatorLast', {});\n    }\n\n    while (operators.length > 0) {\n      addOperator(operators.pop());\n    }\n\n    if (output.length > 1) {\n      throw new ParserError(getTokenPosition(startAt), getTokenPosition(last - 1), 'multipleExpressions', {});\n    }\n\n    if (output.length === 0) {\n      return {\n        result: null,\n        terminator: terminator,\n        last: last\n      };\n    }\n\n    return {\n      result: output[0],\n      terminator: terminator,\n      last: last\n    };\n  };\n\n  for (var i = startAt; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    switch (token.type) {\n      case 'number':\n        output.push({\n          type: 'number',\n          value: token.value\n        });\n        break;\n\n      case 'name':\n        if (getTokenType(i + 1) === 'parens-open') {\n          // Function\n          var _parseListExpression = parseListExpression(input, tokens, i + 2),\n              results = _parseListExpression.results,\n              last = _parseListExpression.last,\n              terminator = _parseListExpression.terminator;\n\n          if (terminator !== 'parens-close') {\n            throw new ParserError(getTokenPosition(i + 1), getTokenPosition(last - 1), 'expectedCloseParens', {});\n          }\n\n          if (token.value === '_') {\n            output.push({\n              type: 'function-placeholder',\n              args: results\n            });\n          } else {\n            output.push({\n              type: 'function',\n              name: token.value,\n              args: results\n            });\n          }\n\n          i = last;\n        } else if (token.value === '_') {\n          output.push({\n            type: 'operand-placeholder'\n          });\n        } else {\n          // Variable\n          output.push({\n            type: 'variable',\n            name: token.value\n          });\n        }\n\n        break;\n\n      case 'matrix-open':\n        if (getTokenType(i + 1) === 'matrix-open') {\n          // Parsing matrix\n          // [[a,b,c][d,e,f][g,h,i]]\n          var values = []; // Extract all nested vectors\n\n          var current = i + 1;\n\n          while (getTokenType(current) === 'matrix-open') {\n            var _parseListExpression2 = parseListExpression(input, tokens, current + 1),\n                _results = _parseListExpression2.results,\n                _last = _parseListExpression2.last,\n                _terminator = _parseListExpression2.terminator;\n\n            if (_terminator !== 'matrix-close') {\n              throw new ParserError(getTokenPosition(current), getTokenPosition(_last - 1), 'expectedSquareBracket', {});\n            }\n\n            if (values.length > 0 && values[0].length !== _results.length) {\n              throw new ParserError(getTokenPosition(current), getTokenPosition(_last), 'matrixMixedDimension', {\n                lengthExpected: values[0].length,\n                lengthReceived: _results.length\n              });\n            }\n\n            if (_results.length === 0) {\n              throw new ParserError(getTokenPosition(current), getTokenPosition(_last), 'matrixEmpty', {});\n            }\n\n            values.push(_results);\n            current = _last + 1;\n          } // The last vector-component should be followed by a closing bracket\n\n\n          if (getTokenType(current) !== 'matrix-close') {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(current - 1), 'expectedSquareBracket', {});\n          }\n\n          output.push({\n            type: 'matrix',\n            n: values[0].length,\n            m: values.length,\n            values: values\n          }); // Advance parsing past closing bracket\n\n          i = current;\n        } else {\n          // Parsing single vector\n          // [a,b,c]\n          var _parseListExpression3 = parseListExpression(input, tokens, i + 1),\n              _results2 = _parseListExpression3.results,\n              _last2 = _parseListExpression3.last,\n              _terminator2 = _parseListExpression3.terminator;\n\n          if (_terminator2 !== 'matrix-close') {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last2 - 1), 'expectedSquareBracket', {});\n          }\n\n          if (_results2.length === 0) {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last2), 'vectorEmpty', {});\n          }\n\n          output.push({\n            type: 'matrix',\n            n: 1,\n            m: _results2.length,\n            values: _results2.map(function (value) {\n              return [value];\n            })\n          });\n          i = _last2;\n        }\n\n        break;\n\n      case 'parens-open':\n        {\n          var _parseSubexpression = parseSubexpression(input, tokens, i + 1),\n              result = _parseSubexpression.result,\n              _last3 = _parseSubexpression.last,\n              _terminator3 = _parseSubexpression.terminator;\n\n          if (_terminator3 !== 'parens-close') {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last3 - 1), 'expectedCloseParens', {});\n          }\n\n          if (result === null) {\n            throw new ParserError(getTokenPosition(i), getTokenPosition(_last3), 'emptyBlock', {});\n          }\n\n          output.push({\n            type: 'block',\n            child: result\n          });\n          i = _last3;\n          break;\n        }\n\n      case 'operator':\n        while (operators.length > 0) {\n          var other = operators[operators.length - 1];\n          var tokenPrecedence = precedence[token.value];\n          var otherPrecedence = precedence[other.value];\n\n          if (otherPrecedence < tokenPrecedence || rightAssociativeOperators.includes(other.value) && otherPrecedence === tokenPrecedence) {\n            break;\n          }\n\n          operators.pop();\n          addOperator(other);\n        }\n\n        operators.push(token);\n        break;\n\n      case 'comma':\n      case 'parens-close':\n      case 'matrix-close':\n        return prepareResult(token.type, i);\n\n      default:\n        throwUnknownType(token, function (type) {\n          return \"Equation render: cannot resolve type \\\"\".concat(type, \"\\\"\");\n        });\n    }\n  }\n\n  return prepareResult('end', tokens.length);\n};\n\nvar parse = function parse(input) {\n  try {\n    var tokens = tokenize(input);\n\n    var _parseSubexpression = parseSubexpression(input, tokens, 0),\n        result = _parseSubexpression.result,\n        last = _parseSubexpression.last,\n        terminator = _parseSubexpression.terminator;\n\n    if (terminator !== 'end') {\n      throw new ParserError(tokens[last].position, tokens[last].position, 'expectedEnd', {});\n    }\n\n    if (result === null) {\n      throw new ParserError(0, 0, 'expectedEnd', {});\n    }\n\n    return result;\n  } catch (error) {\n    if (error instanceof ParserError) {\n      return error.getParserError(input);\n    } else {\n      throw error;\n    }\n  }\n};\n\nvar renderTree = function renderTree(tree) {\n  if (tree.type === 'parser-error') {\n    return \"\".concat(tree.errorType, \" error\\n  \").concat(tree.equation, \"\\n  \").concat(''.padStart(tree.start, ' ').padEnd(tree.end + 1, '^'));\n  }\n\n  return pushTree(tree).join('\\n');\n};\nvar operatorMap$1 = {\n  'equals': '=',\n  'less-than': '<',\n  'greater-than': '>',\n  'less-than-equals': '≤',\n  'greater-than-equals': '≥',\n  'approximates': '≈',\n  'plus': '+',\n  'minus': '-',\n  'plus-minus': '±',\n  'multiply-implicit': '*',\n  'multiply-dot': '*',\n  'multiply-cross': '×',\n  'divide-fraction': '/',\n  'divide-inline': '÷',\n  'power': '^',\n  'operator-placeholder': '?'\n};\nvar unaryOperatorMap$1 = {\n  'positive': '+',\n  'negative': '-',\n  'positive-negative': '±',\n  'operator-unary-placeholder': '?'\n};\n\nfunction pushTree(tree) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var indentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'initial';\n  var ownIndent = indent;\n  var descendantIndent = indent;\n\n  switch (indentType) {\n    case 'regular':\n      ownIndent += '├─ ';\n      descendantIndent += '│  ';\n      break;\n\n    case 'last':\n      ownIndent += '└─ ';\n      descendantIndent += '   ';\n      break;\n  }\n\n  switch (tree.type) {\n    case 'number':\n      buffer.push(ownIndent + tree.value);\n      break;\n\n    case 'variable':\n      buffer.push(\"\".concat(ownIndent, \"\\\"\").concat(tree.name, \"\\\"\"));\n      break;\n\n    case 'positive':\n    case 'negative':\n    case 'positive-negative':\n    case 'operator-unary-placeholder':\n      buffer.push(ownIndent + unaryOperatorMap$1[tree.type]);\n      pushTree(tree.value, buffer, descendantIndent, 'last');\n      break;\n\n    case 'block':\n      buffer.push(\"\".concat(ownIndent, \"()\"));\n      pushTree(tree.child, buffer, descendantIndent, 'last');\n      break;\n\n    case 'equals':\n    case 'less-than':\n    case 'greater-than':\n    case 'less-than-equals':\n    case 'greater-than-equals':\n    case 'approximates':\n    case 'plus':\n    case 'minus':\n    case 'plus-minus':\n    case 'multiply-implicit':\n    case 'multiply-dot':\n    case 'multiply-cross':\n    case 'divide-fraction':\n    case 'divide-inline':\n    case 'power':\n    case 'operator-placeholder':\n      buffer.push(ownIndent + operatorMap$1[tree.type]);\n      pushTree(tree.a, buffer, descendantIndent, 'regular');\n      pushTree(tree.b, buffer, descendantIndent, 'last');\n      break;\n\n    case 'function':\n      buffer.push(\"\".concat(ownIndent).concat(tree.name, \"()\"));\n      tree.args.forEach(function (arg, idx) {\n        pushTree(arg, buffer, descendantIndent, idx < tree.args.length - 1 ? 'regular' : 'last');\n      });\n      break;\n\n    case 'function-placeholder':\n      buffer.push(\"\".concat(ownIndent, \"<placeholder>()\"));\n      tree.args.forEach(function (arg, idx) {\n        pushTree(arg, buffer, descendantIndent, idx < tree.args.length - 1 ? 'regular' : 'last');\n      });\n      break;\n\n    case 'matrix':\n      if (tree.n === 1) {\n        buffer.push(\"\".concat(ownIndent, \"v \").concat(tree.m));\n        tree.values.forEach(function (row, idx) {\n          pushTree(row[0], buffer, descendantIndent, idx < tree.m - 1 ? 'regular' : 'last');\n        });\n      } else {\n        buffer.push(\"\".concat(ownIndent, \"m \").concat(tree.m, \"x\").concat(tree.n));\n        tree.values.forEach(function (row, rowIdx) {\n          var rowIndent = descendantIndent + (rowIdx < tree.m - 1 ? '│  ' : '   ');\n          row.forEach(function (cell, cellIdx) {\n            if (cellIdx === 0) {\n              if (rowIdx < tree.m - 1) {\n                pushTree(cell, buffer, descendantIndent + '├──┬─ ', 'initial');\n              } else {\n                pushTree(cell, buffer, descendantIndent + '└──┬─ ', 'initial');\n              }\n            } else {\n              pushTree(cell, buffer, rowIndent, cellIdx < tree.n - 1 ? 'regular' : 'last');\n            }\n          });\n        });\n      }\n\n      break;\n\n    case 'operand-placeholder':\n      buffer.push(\"\".concat(ownIndent, \"<placeholder>\"));\n      break;\n\n    default:\n      throwUnknownType(tree, function (type) {\n        return \"Equation tree to string: cannot resolve type \\\"\".concat(type, \"\\\"\");\n      });\n  }\n\n  return buffer;\n}\n\nvar stringify = function stringify(tree) {\n  if (tree.type === 'parser-error') {\n    return tree.equation;\n  }\n\n  var buffer = [];\n  stringifyTree(tree, buffer);\n  return buffer.join('');\n};\nvar operatorMap$2 = {\n  'equals': ' = ',\n  'less-than': ' < ',\n  'greater-than': ' > ',\n  'less-than-equals': ' ≤ ',\n  'greater-than-equals': ' ≥ ',\n  'approximates': ' ≈ ',\n  'plus': ' + ',\n  'minus': ' - ',\n  'plus-minus': ' ± ',\n  'multiply-implicit': ' ',\n  'multiply-dot': ' * ',\n  'multiply-cross': ' × ',\n  'divide-fraction': ' / ',\n  'divide-inline': ' ÷ ',\n  'power': ' ^ ',\n  'operator-placeholder': ' ? '\n};\nvar unaryOperatorMap$2 = {\n  'positive': '+',\n  'negative': '-',\n  'positive-negative': '±',\n  'operator-unary-placeholder': '?'\n};\n\nfunction stringifyTree(tree, buffer) {\n  switch (tree.type) {\n    case 'number':\n      buffer.push(tree.value.toString());\n      break;\n\n    case 'variable':\n      buffer.push(tree.name);\n      break;\n\n    case 'positive':\n    case 'negative':\n    case 'positive-negative':\n    case 'operator-unary-placeholder':\n      buffer.push(unaryOperatorMap$2[tree.type]);\n      stringifyTree(tree.value, buffer);\n      break;\n\n    case 'block':\n      buffer.push('(');\n      stringifyTree(tree.child, buffer);\n      buffer.push(')');\n      break;\n\n    case 'plus':\n    case 'minus':\n    case 'plus-minus':\n    case 'divide-fraction':\n    case 'divide-inline':\n    case 'multiply-implicit':\n    case 'multiply-dot':\n    case 'multiply-cross':\n    case 'power':\n    case 'equals':\n    case 'less-than':\n    case 'greater-than':\n    case 'less-than-equals':\n    case 'greater-than-equals':\n    case 'approximates':\n    case 'operator-placeholder':\n      stringifyTree(tree.a, buffer);\n      buffer.push(operatorMap$2[tree.type]);\n      stringifyTree(tree.b, buffer);\n      break;\n\n    case 'function':\n    case 'function-placeholder':\n      buffer.push(tree.type === 'function' ? tree.name : '_');\n      buffer.push('(');\n      tree.args.forEach(function (arg, idx) {\n        if (idx > 0) {\n          buffer.push(',');\n        }\n\n        stringifyTree(arg, buffer);\n      });\n      buffer.push(')');\n      break;\n\n    case 'matrix':\n      buffer.push('[');\n      tree.values.forEach(function (row, rowIdx) {\n        if (tree.n > 1) {\n          buffer.push('[');\n        } else if (rowIdx > 0) {\n          buffer.push(',');\n        }\n\n        row.forEach(function (cell, cellIdx) {\n          if (cellIdx > 0) {\n            buffer.push(',');\n          }\n\n          stringifyTree(cell, buffer);\n        });\n\n        if (tree.n > 1) {\n          buffer.push(']');\n        }\n      });\n      buffer.push(']');\n      break;\n\n    case 'operand-placeholder':\n      buffer.push('_');\n      break;\n\n    default:\n      throwUnknownType(tree, function (type) {\n        return \"Equation tree to string: cannot resolve type \\\"\".concat(type, \"\\\"\");\n      });\n  }\n}\n\nexport { parse, renderTree, stringify };\n"]},"metadata":{},"sourceType":"module"}