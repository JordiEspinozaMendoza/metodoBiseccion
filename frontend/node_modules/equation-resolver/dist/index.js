'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ResolverError = /*#__PURE__*/function (_Error) {
  _inherits(ResolverError, _Error);

  var _super = _createSuper(ResolverError);

  function ResolverError(type, errorNode, values) {
    var _this;

    _classCallCheck(this, ResolverError);

    _this = _super.call(this, "Internal ".concat(type, " parse error"));

    _defineProperty(_assertThisInitialized(_this), "type", void 0);

    _defineProperty(_assertThisInitialized(_this), "errorNode", void 0);

    _defineProperty(_assertThisInitialized(_this), "values", void 0);

    _this.type = type;
    _this.errorNode = errorNode;
    _this.values = values;
    return _this;
  }

  _createClass(ResolverError, [{
    key: "getResolveError",
    value: function getResolveError() {
      return _objectSpread2({
        type: 'resolve-error',
        errorType: this.type,
        errorNode: this.errorNode
      }, this.values);
    }
  }]);

  return ResolverError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var checkArgs = function checkArgs(node, minArgs, maxArgs) {
  if (node.args.length < minArgs || node.args.length > maxArgs) {
    throw new ResolverError('functionArgLength', node, {
      name: node.name,
      minArgs: minArgs,
      maxArgs: maxArgs
    });
  }
};

function getUnit(x) {
  if (x.type === 'unit') {
    return x.units;
  } else {
    return {};
  }
}
function getUnitless(x) {
  if (x.type === 'unit') {
    return x.value;
  } else {
    return x;
  }
}
function isSameUnit(a, b) {
  var keys = Object.keys(a);
  return keys.length === Object.keys(b).length && keys.every(function (key) {
    return a[key] === b[key];
  });
}
function isEmptyUnit(x) {
  return Object.keys(x).length === 0;
}
function combineUnits(a, b, mapper) {
  // Get all units from a
  var result = mapUnit(a, function (value, key) {
    return mapper(value, b[key] || 0, key);
  }); // Get remaining units from b

  for (var _i = 0, _Object$entries = Object.entries(b); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        _key = _Object$entries$_i[0],
        _value = _Object$entries$_i[1];

    if (_key in a) {
      continue;
    }

    var newValue = mapper(0, _value, _key);

    if (newValue !== 0) {
      result[_key] = newValue;
    }
  }

  return result;
}
function mapUnit(x, mapper) {
  var result = {};

  for (var _i2 = 0, _Object$entries2 = Object.entries(x); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        _key2 = _Object$entries2$_i[0],
        _value2 = _Object$entries2$_i[1];

    var newValue = mapper(_value2, _key2);

    if (newValue !== 0) {
      result[_key2] = newValue;
    }
  }

  return result;
}

var valueWrap = function valueWrap(x) {
  return {
    type: 'number',
    value: x
  };
};

var mapMatrix = function mapMatrix(result, mapper) {
  return {
    type: 'matrix',
    m: result.m,
    n: result.n,
    values: result.values.map(function (row) {
      return row.map(mapper);
    })
  };
};

/**
 * Compiler-error and runtime-error on unhandled type
 *
 * @param typed: Object with type-property
 * @param getMessage: get an error message for runtime errors
 */
function throwUnknownType(typed, getMessage) {
  throw new Error(getMessage(typed && typed.type || 'unknown'));
}

// don't narrow from control-flow (ie. T remains ResultNode in switch)

var negate = function negate(value) {
  var castValue = value;

  switch (castValue.type) {
    case 'number':
      return valueWrap(-castValue.value);

    case 'matrix':
      return mapMatrix(castValue, function (cell) {
        return negate(cell);
      });

    case 'unit':
      return {
        type: 'unit',
        units: _objectSpread2({}, castValue.units),
        value: negate(castValue.value)
      };

    default:
      return throwUnknownType(castValue, function (type) {
        return "Equation resolve: cannot resolve type \"".concat(type, "\"");
      });
  }
};

function plus(node, aTree, bTree) {
  return handleCases(node, aTree, bTree, function (a, b) {
    if (!isSameUnit(a, b)) {
      throw new ResolverError('plusDifferentUnits', node, {});
    }

    return a;
  }, // number, number
  function (a, b) {
    return valueWrap(a.value + b.value);
  }, // number, matrix
  function (a, b) {
    return mapMatrix(b, function (cell) {
      return plus(node, a, cell);
    });
  }, // matrix, number
  function (a, b) {
    return mapMatrix(a, function (cell) {
      return plus(node, cell, b);
    });
  }, // matrix, matrix
  function (a, b) {
    if (a.n !== b.n || a.m !== b.m) {
      throw new ResolverError('plusMatrixMismatch', node, {
        aDimensions: "".concat(a.m, "x").concat(a.n),
        bDimensions: "".concat(b.m, "x").concat(b.n)
      });
    }

    return {
      type: 'matrix',
      m: a.m,
      n: a.n,
      values: a.values.map(function (row, rowIdx) {
        return row.map(function (cell, cellIdx) {
          return plus(node, cell, b.values[rowIdx][cellIdx]);
        });
      })
    };
  });
}
function minus(node, a, b) {
  return plus(node, a, negate(b));
} // eslint-disable-next-line @typescript-eslint/no-unused-vars

function multiply(node, aTree, bTree, multiplyVectors) {
  return handleCases(node, aTree, bTree, function (a, b) {
    return combineUnits(a, b, function (unit1, unit2) {
      return unit1 + unit2;
    });
  }, // number, number
  function (a, b) {
    return valueWrap(a.value * b.value);
  }, // number, matrix
  function (a, b) {
    return mapMatrix(b, function (cell) {
      return multiply(node, a, cell, multiplyVectors);
    });
  }, // matrix, number
  function (a, b) {
    return mapMatrix(a, function (cell) {
      return multiply(node, cell, b, multiplyVectors);
    });
  }, // matrix, matrix
  function (a, b) {
    if (a.n === 1 && b.n === 1) {
      return multiplyVectors(node, a, b);
    } else {
      return matrixProduct(node, a, b);
    }
  });
}

function scalarProduct(node, a, b) {
  if (a.m !== b.m) {
    throw new ResolverError('scalarProductUnbalanced', node, {
      aLength: a.m,
      bLength: b.m
    });
  }

  var sum = a.values.reduce(function (current, row, rowIdx) {
    return current + row[0].value * b.values[rowIdx][0].value;
  }, 0);
  return valueWrap(sum);
}

function vectorProduct(node, a, b) {
  if (a.m !== 3 || b.m !== 3) {
    throw new ResolverError('vectorProduct3VectorOnly', node, {});
  }

  return {
    type: 'matrix',
    n: 1,
    m: 3,
    values: [[valueWrap(a.values[1][0].value * b.values[2][0].value - a.values[2][0].value * b.values[1][0].value)], [valueWrap(a.values[2][0].value * b.values[0][0].value - a.values[0][0].value * b.values[2][0].value)], [valueWrap(a.values[0][0].value * b.values[1][0].value - a.values[1][0].value * b.values[0][0].value)]]
  };
}

function matrixProduct(node, a, b) {
  if (a.n !== b.m) {
    throw new ResolverError('matrixProductMatrixMismatch', node, {
      aDimensions: "".concat(a.m, "x").concat(a.n),
      bDimensions: "".concat(b.m, "x").concat(b.n)
    });
  }

  return {
    type: 'matrix',
    m: a.m,
    n: b.n,
    values: a.values.map(function (row, aRow) {
      return b.values[0].map(function (cell, bCol) {
        return valueWrap(a.values[aRow].reduce(function (current, innerCell, colIdx) {
          return current + innerCell.value * b.values[colIdx][bCol].value;
        }, 0));
      });
    })
  };
}

function multiplyImplicit(node, a, b) {
  if (a.type === 'matrix' && b.type === 'matrix' && a.n === 1 && b.n === 1) {
    throw new ResolverError('multiplyImplicitNoVectors', node, {});
  }

  return multiply(node, a, b, scalarProduct);
}
function multiplyDot(node, a, b) {
  return multiply(node, a, b, scalarProduct);
}
function multiplyCross(node, a, b) {
  return multiply(node, a, b, vectorProduct);
}
function divide(node, aTree, bTree) {
  if (aTree.type === 'matrix' && bTree.type === 'matrix') {
    throw new ResolverError('divideMatrixMatrix', node, {});
  }

  if (bTree.type === 'number' && bTree.value === 0) {
    throw new ResolverError('divideNotZero', node, {});
  }

  if (bTree.type === 'matrix' && bTree.values.some(function (row) {
    return row.some(function (cell) {
      return cell.value === 0;
    });
  })) {
    throw new ResolverError('divideNotZero', node, {});
  }

  return handleCases(node, aTree, bTree, function (a, b) {
    return combineUnits(a, b, function (factor1, factor2) {
      return factor1 - factor2;
    });
  }, // number, number
  function (a, b) {
    return valueWrap(a.value / b.value);
  }, // number, matrix
  function (a, b) {
    return mapMatrix(b, function (cell) {
      return divide(node, a, cell);
    });
  }, // matrix, number
  function (a, b) {
    return mapMatrix(a, function (cell) {
      return divide(node, cell, b);
    });
  }, // matrix, matrix
  null);
}
function power(node, aTree, bTree) {
  if (bTree.type !== 'number') {
    throw new ResolverError('powerUnitlessNumberExponent', node, {});
  }

  return handleCases(node, aTree, bTree, function (a) {
    return mapUnit(a, function (factor) {
      return factor * bTree.value;
    });
  }, // number, number
  function (a, b) {
    return valueWrap(Math.pow(a.value, b.value));
  }, // number, matrix
  null, // matrix, number
  function (a, b) {
    return mapMatrix(a, function (cell) {
      return valueWrap(Math.pow(cell.value, b.value));
    });
  }, // matrix, matrix
  null);
}

function handleCases(node, a, b, combineUnits, numberNumber, numberMatrix, matrixNumber, matrixMatrix) {
  if (a.type === 'unit' || b.type === 'unit') {
    var units = combineUnits(getUnit(a), getUnit(b));
    var result = handleCases(node, getUnitless(a), getUnitless(b), combineUnits, numberNumber, numberMatrix, matrixNumber, matrixMatrix);

    if (isEmptyUnit(units)) {
      return result;
    } else {
      return {
        type: 'unit',
        units: units,
        value: result
      };
    }
  }

  switch (a.type) {
    case 'number':
      switch (b.type) {
        case 'number':
          if (numberNumber) {
            return numberNumber(a, b);
          }

          break;

        case 'matrix':
          if (numberMatrix) {
            return numberMatrix(a, b);
          }

          break;
      }

      break;

    case 'matrix':
      {
        switch (b.type) {
          case 'number':
            if (matrixNumber) {
              return matrixNumber(a, b);
            }

            break;

          case 'matrix':
            if (matrixMatrix) {
              return matrixMatrix(a, b);
            }

            break;
        }

        break;
      }
  }

  throw new ResolverError('operatorInvalidArguments', node, {
    operator: node.type,
    a: a.type,
    b: b.type
  });
}

var resolve = function resolve(node) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (node.type === 'parser-error') {
    return {
      type: 'resolve-error',
      errorType: 'invalidEquation',
      errorNode: null
    };
  }

  try {
    return resolveNode(node, options);
  } catch (error) {
    if (error instanceof ResolverError) {
      return error.getResolveError();
    } else {
      throw error;
    }
  }
};
var resolveNode = function resolveNode(node, options) {
  switch (node.type) {
    case 'number':
      return {
        type: 'number',
        value: parseFloat(node.value)
      };

    case 'variable':
      return resolveVariable(node, options);

    case 'positive':
      return resolveNode(node.value, options);

    case 'negative':
      return negate(resolveNode(node.value, options));

    case 'positive-negative':
      throw new ResolverError('plusminusUnhandled', node, {});

    case 'block':
      return resolveNode(node.child, options);

    case 'plus':
      return plus(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'minus':
      return minus(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'plus-minus':
      throw new ResolverError('plusminusUnhandled', node, {});

    case 'multiply-implicit':
      return multiplyImplicit(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'multiply-dot':
      return multiplyDot(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'multiply-cross':
      return multiplyCross(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'divide-fraction':
    case 'divide-inline':
      return divide(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'power':
      return power(node, resolveNode(node.a, options), resolveNode(node.b, options));

    case 'function':
      return resolveFunction(node, options);

    case 'equals':
    case 'less-than':
    case 'less-than-equals':
    case 'greater-than':
    case 'greater-than-equals':
    case 'approximates':
      throw new ResolverError('noComparison', node, {});

    case 'matrix':
      {
        // Keep track of resolved unit
        var unit = null;
        var values = node.values.map(function (row) {
          return row.map(function (cell) {
            var value = resolveNode(cell, options); // Compare units

            if (unit) {
              if (!isSameUnit(unit, getUnit(value))) {
                throw new ResolverError('matrixDifferentUnits', node, {});
              }
            } else {
              unit = getUnit(value);
            } // Ensure all children are unitless numbers


            var unitlessValue = getUnitless(value);

            if (unitlessValue.type !== 'number') {
              throw new ResolverError('matrixNoNesting', node, {});
            }

            return unitlessValue;
          });
        }); // Wrap in unit if necessary

        if (!unit || isEmptyUnit(unit)) {
          return {
            type: 'matrix',
            m: node.m,
            n: node.n,
            values: values
          };
        } else {
          return {
            type: 'unit',
            units: unit,
            value: {
              type: 'matrix',
              m: node.m,
              n: node.n,
              values: values
            }
          };
        }
      }

    case 'function-placeholder':
    case 'operand-placeholder':
    case 'operator-placeholder':
    case 'operator-unary-placeholder':
      throw new ResolverError('placeholder', node, {});

    default:
      return throwUnknownType(node, function (type) {
        return "Equation resolve: cannot resolve type \"".concat(type, "\"");
      });
  }
};

function resolveVariable(node, options) {
  if (!options.variables || !options.variables[node.name]) {
    throw new ResolverError('variableUnknown', node, {
      name: node.name
    });
  }

  return options.variables[node.name];
}

function resolveFunction(node, options) {
  if (!options.functions || !options.functions[node.name]) {
    throw new ResolverError('functionUnknown', node, {
      name: node.name
    });
  }

  return options.functions[node.name](node, options);
}

var createResolverFunction = function createResolverFunction(argNames, expression, options) {
  var expressionOptions = {
    variables: _objectSpread2({}, options.variables),
    functions: _objectSpread2({}, options.functions)
  };
  return function (node, argOptions) {
    checkArgs(node, argNames.length, argNames.length);
    argNames.forEach(function (n, idx) {
      expressionOptions.variables[n] = resolveNode(node.args[idx], argOptions);
    });
    return resolveNode(expression, expressionOptions);
  };
};

var defaultSimplifiableUnits = ['N', 'J', 'W', 'Pa', 'Hz', 'lx', 'C', 'V', 'F', 'Ω', 'S', 'Wb', 'T', 'H', 'Gy'];
var format = function format(equation) {
  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (equation.type === 'parser-error') {
    return equation;
  }

  if (unit && unit.type === 'parser-error') {
    return unit;
  }

  if (unit && !isUnitTree(unit)) {
    return {
      type: 'resolve-error',
      errorType: 'invalidUnit',
      node: wrapError(equation, unit),
      errorNode: unit
    };
  }

  var result = resolve(equation, options);
  var unitResult = unit ? resolve(unit, options) : null;

  if (result.type === 'resolve-error') {
    return _objectSpread2(_objectSpread2({}, result), {}, {
      node: wrapError(equation, unit)
    });
  }

  if (unitResult && unitResult.type === 'resolve-error') {
    return _objectSpread2(_objectSpread2({}, unitResult), {}, {
      node: wrapError(equation, unit)
    });
  }

  if (unitResult && !isUnitResult(unitResult)) {
    return {
      type: 'resolve-error',
      errorType: 'invalidUnit',
      node: wrapError(equation, unit),
      errorNode: unit
    };
  }

  return {
    type: 'equals',
    a: equation,
    b: resultToEquationWithUnit(result, unit, unitResult, options)
  };
};

var wrapError = function wrapError(equation, unit) {
  return {
    type: 'equals',
    a: equation,
    b: unit ? {
      type: 'multiply-implicit',
      a: {
        type: 'operand-placeholder'
      },
      b: unit
    } : {
      type: 'operand-placeholder'
    }
  };
};

function resultToEquationWithUnit(result, unit, unitResult, options) {
  if (unit && unitResult) {
    var value = divide(unit, getUnitless(result), getUnitless(unitResult));
    var diffUnits = combineUnits(getUnit(result), getUnit(unitResult), function (a, b) {
      return a - b;
    });

    if (isEmptyUnit(diffUnits)) {
      return wrapUnit(resultToEquation(value, options), unit);
    } else {
      return wrapUnit(resultToEquation(value, options), {
        type: 'multiply-implicit',
        a: unit,
        b: unitToEquation(diffUnits)
      });
    }
  } else {
    return resultToEquation(result, options);
  }
}

function resultToEquation(result, options) {
  switch (result.type) {
    case 'number':
      if (result.value < 0) {
        return {
          type: 'negative',
          value: simplifyNumber(-result.value)
        };
      } else {
        return simplifyNumber(result.value);
      }

    case 'matrix':
      return {
        type: 'matrix',
        m: result.m,
        n: result.n,
        values: result.values.map(function (row) {
          return row.map(function (cell) {
            return resultToEquation(cell, options);
          });
        })
      };

    case 'unit':
      {
        var unit = guessUnit(result, options);
        return wrapUnit(resultToEquation(unit.value, options), unitToEquation(unit.units));
      }
  }
}

function simplifyNumber(value) {
  // Handle infinity
  if (value === Infinity) {
    return {
      type: 'variable',
      name: '∞'
    };
  } // Float exponent


  var factor = Math.log10(value);

  if (value === 0 || Math.abs(factor) < 5) {
    // Retain regular number
    return {
      type: 'number',
      value: formatNumber(value)
    };
  } else {
    // Rewrite as power-of-ten
    var exponent = Math.floor(factor);
    var significand = value / Math.pow(10, exponent);
    return {
      type: 'multiply-dot',
      a: {
        type: 'number',
        value: formatNumber(significand)
      },
      b: {
        type: 'power',
        a: {
          type: 'number',
          value: '10'
        },
        b: {
          type: 'number',
          value: formatNumber(exponent)
        }
      }
    };
  }
}

function formatNumber(value) {
  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  var commaSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  return ensurePrecision(value, digits).split('.').join(commaSep);
} // number.toPrecision with trailing zeros stripped
// Avoids scientific notation for large numbers


function ensurePrecision(value, digits) {
  // Handle cases where scientific notation would be used
  if (Math.log(Math.abs(value)) * Math.LOG10E >= digits) {
    return Math.round(value).toString();
  } // Strip trailing zeroes


  return Number(value.toPrecision(digits)).toString();
}

function isUnitTree(unitTree) {
  switch (unitTree.type) {
    case 'multiply-implicit':
    case 'multiply-dot':
    case 'multiply-cross':
    case 'divide-fraction':
    case 'divide-inline':
      return isUnitTree(unitTree.a) && isUnitTree(unitTree.b);

    case 'power':
      return unitTree.a.type === 'variable' && unitTree.b.type === 'number';

    case 'variable':
      return true;

    default:
      return false;
  }
}

function isUnitResult(unitResult) {
  switch (unitResult.type) {
    case 'unit':
      return isUnitResult(unitResult.value);

    case 'number':
      return true;

    default:
      return false;
  }
}

function wrapUnit(value, units) {
  // Retain proper ordering of operations be letting negative wrap multiplication
  if (value.type === 'negative') {
    return {
      type: 'negative',
      value: {
        type: 'multiply-implicit',
        a: value.value,
        b: units
      }
    };
  } else {
    return {
      type: 'multiply-implicit',
      a: value,
      b: units
    };
  }
}

function guessUnit(result, _ref) {
  var _ref$simplifiableUnit = _ref.simplifiableUnits,
      simplifiableUnits = _ref$simplifiableUnit === void 0 ? defaultSimplifiableUnits : _ref$simplifiableUnit,
      _ref$variables = _ref.variables,
      variables = _ref$variables === void 0 ? {} : _ref$variables;
  var unit = simplifiableUnits.find(function (u) {
    var variable = variables[u];
    return variable && variable.type === 'unit' && variable.value.type === 'number' && isSameUnit(variable.units, result.units);
  });

  if (unit) {
    var variable = variables[unit];
    return {
      type: 'unit',
      units: _defineProperty({}, unit, 1),
      value: divide({}, result.value, variable.value)
    };
  } else {
    return result;
  }
}

function getExponent(unit, factor) {
  if (factor === 1) {
    return {
      type: 'variable',
      name: unit
    };
  } else {
    return {
      type: 'power',
      a: {
        type: 'variable',
        name: unit
      },
      b: {
        type: 'number',
        value: factor.toString()
      }
    };
  }
}

function unitToEquation(units) {
  // Terms above fraction
  var positive = []; // Terms below fraction

  var negative = [];

  for (var _i = 0, _Object$entries = Object.entries(units); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        unit = _Object$entries$_i[0],
        factor = _Object$entries$_i[1];

    if (factor > 0) {
      positive.push(getExponent(unit, factor));
    } else {
      negative.push(getExponent(unit, -factor));
    }
  }

  if (negative.length === 0) {
    return multiplyList(positive);
  }

  return {
    type: 'divide-fraction',
    a: multiplyList(positive),
    b: multiplyList(negative)
  };
}

function multiplyList(list) {
  if (list.length === 0) {
    return {
      type: 'number',
      value: '1'
    };
  }

  var current = list[0]; // Build multiplication tree

  for (var i = 1; i < list.length; i++) {
    current = {
      type: 'multiply-implicit',
      a: current,
      b: list[i]
    };
  }

  return current;
}

var isInteger = function isInteger(x) {
  return x.type === 'number' && Math.round(x.value) === x.value;
};

var createNumberFunction = function createNumberFunction(func) {
  var minArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var maxArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : minArgs;
  var validate = arguments.length > 3 ? arguments[3] : undefined;
  return function (node, options) {
    checkArgs(node, minArgs, maxArgs);
    var resolvedArgs = node.args.map(function (arg) {
      return resolveNode(arg, options);
    });
    var nonNumber = resolvedArgs.findIndex(function (arg) {
      return arg.type !== 'number';
    });

    if (nonNumber !== -1) {
      throw new ResolverError('functionNumberOnly', node.args[nonNumber], {
        name: node.name
      });
    }

    var numberArgs = resolvedArgs.map(function (arg) {
      return arg.value;
    });

    if (validate) {
      var result = validate.apply(void 0, [node.name].concat(_toConsumableArray(numberArgs)));

      if (result) {
        throw new ResolverError(result[1], node.args[result[0]], {
          name: node.name
        });
      }
    }

    return valueWrap(func.apply(void 0, _toConsumableArray(numberArgs)));
  };
};

var defaultFunctions = {
  sin: createNumberFunction(Math.sin),
  cos: createNumberFunction(Math.cos),
  tan: createNumberFunction(Math.tan),
  asin: createNumberFunction(Math.asin),
  acos: createNumberFunction(Math.acos),
  atan: createNumberFunction(Math.atan),
  atan2: createNumberFunction(Math.atan2, 2),
  abs: createNumberFunction(Math.abs),
  ceil: createNumberFunction(Math.ceil),
  floor: createNumberFunction(Math.floor),
  round: createNumberFunction(function (x) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var factor = Math.pow(10, precision);
    return Math.round(x * factor) / factor;
  }, 1, 2),
  max: createNumberFunction(Math.max, 1, Infinity),
  min: createNumberFunction(Math.min, 1, Infinity),
  pow: createNumberFunction(Math.pow, 2),
  sqrt: createNumberFunction(Math.sqrt, 1, 1, function (name, x) {
    if (x < 0) {
      return [0, 'functionSqrt1Positive'];
    }
  }),
  root: createNumberFunction(function (f, x) {
    return Math.sign(x) * Math.pow(Math.abs(x), 1 / f);
  }, 2, 2, function (name, f, x) {
    if (Math.round(f) !== f || f <= 0) {
      return [0, 'functionRoot1PositiveInteger'];
    }

    if (f % 2 === 0 && x < 0) {
      return [1, 'functionRoot2Positive'];
    }
  }),
  ln: createNumberFunction(Math.log),
  log: createNumberFunction(function (x) {
    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    return Math.log(x) / Math.log(base);
  }, 1, 2),
  sum: function sum(node, options) {
    checkArgs(node, 4, 4);

    var _node$args = _slicedToArray(node.args, 4),
        variable = _node$args[0],
        startTree = _node$args[1],
        endTree = _node$args[2],
        expression = _node$args[3];

    if (variable.type !== 'variable') {
      throw new ResolverError('functionSum1Variable', variable, {
        name: node.name,
        variableType: variable.type
      });
    }

    var start = resolveNode(startTree, options);
    var end = resolveNode(endTree, options);

    if (!isInteger(start)) {
      throw new ResolverError('functionSum2Integer', startTree, {
        name: node.name
      });
    }

    if (!isInteger(end)) {
      throw new ResolverError('functionSum3Integer', endTree, {
        name: node.name
      });
    }

    if (start > end) {
      var _ref = [end, start];
      start = _ref[0];
      end = _ref[1];
    }

    var enhancedOptions = {
      functions: options.functions,
      variables: _objectSpread2({}, options.variables)
    }; // Get initial value

    enhancedOptions.variables[variable.name] = start;
    var sum = resolveNode(expression, enhancedOptions);

    for (var i = start.value + 1; i <= end.value; i++) {
      enhancedOptions.variables[variable.name] = valueWrap(i);
      sum = plus(node, sum, resolveNode(expression, enhancedOptions));
    }

    return sum;
  }
};

var defaultVariables = {
  // ========================================================================
  // Mathematical constants
  // ========================================================================
  'e': valueWrap(Math.E),
  'pi': valueWrap(Math.PI),
  'π': valueWrap(Math.PI),
  'phi': valueWrap(1.618033988749895),
  'φ': valueWrap(1.618033988749895),
  // ========================================================================
  // Length
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'pm': unitWrap(1e-12, {
    m: 1
  }),
  // picometer
  'nm': unitWrap(1e-9, {
    m: 1
  }),
  // nanometer
  'μm': unitWrap(1e-6, {
    m: 1
  }),
  // micrometer
  'mm': unitWrap(1e-3, {
    m: 1
  }),
  // millimeter
  'cm': unitWrap(1e-2, {
    m: 1
  }),
  // centimeter
  'dm': unitWrap(1e-1, {
    m: 1
  }),
  // decimeter
  'm': unitWrap(1e0, {
    m: 1
  }),
  // meter (base unit)
  'km': unitWrap(1e3, {
    m: 1
  }),
  // kilometer
  'Mm': unitWrap(1e6, {
    m: 1
  }),
  // megameter
  'Gm': unitWrap(1e9, {
    m: 1
  }),
  // gigameter
  // Imperial ---------------------------------------------------------------
  'thou': unitWrap(2.54e-7, {
    m: 1
  }),
  // thou, 1/1000 inch
  'mil': unitWrap(2.54e-7, {
    m: 1
  }),
  // mil, 1/1000 inch
  'in': unitWrap(2.54e-2, {
    m: 1
  }),
  // inch
  '"': unitWrap(2.54e-2, {
    m: 1
  }),
  // inch, " symbol
  'ft': unitWrap(0.3048, {
    m: 1
  }),
  // foot
  '\'': unitWrap(0.3048, {
    m: 1
  }),
  // foot, ' symbol
  'yd': unitWrap(0.9144, {
    m: 1
  }),
  // yard
  'mi': unitWrap(1609.344, {
    m: 1
  }),
  // mile
  // Others -----------------------------------------------------------------
  'NM': unitWrap(1852, {
    m: 1
  }),
  // natical mile
  'nmi': unitWrap(1852, {
    m: 1
  }),
  // natical mile
  'Å': unitWrap(1e-10, {
    m: 1
  }),
  // ångström
  'AU': unitWrap(1.4959787e11, {
    m: 1
  }),
  // astronomical unit
  'pc': unitWrap(3.0856776e16, {
    m: 1
  }),
  // parsec
  'ls': unitWrap(2.99792458e8, {
    m: 1
  }),
  // light-second
  'ly': unitWrap(9.46073047e15, {
    m: 1
  }),
  // light-year
  'Kly': unitWrap(9.46073047e18, {
    m: 1
  }),
  // kilolight-year
  'Mly': unitWrap(9.46073047e21, {
    m: 1
  }),
  // megalight-year
  'Gly': unitWrap(9.46073047e24, {
    m: 1
  }),
  // gigalight-year
  // ========================================================================
  // Area
  // ========================================================================
  // Imperial ---------------------------------------------------------------
  'ac': unitWrap(4046.856, {
    m: 2
  }),
  // acre (international)
  // Others -----------------------------------------------------------------
  'ha': unitWrap(1e4, {
    m: 2
  }),
  // hectare
  'b': unitWrap(1e-28, {
    m: 2
  }),
  // barn (physics)
  // ========================================================================
  // Volume
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'μL': unitWrap(1e-9, {
    m: 3
  }),
  // microliter
  'mL': unitWrap(1e-6, {
    m: 3
  }),
  // milliliter
  'cL': unitWrap(1e-5, {
    m: 3
  }),
  // centiliter
  'dL': unitWrap(1e-4, {
    m: 3
  }),
  // deciliter
  'L': unitWrap(1e-3, {
    m: 3
  }),
  // liter
  // Imperial ---------------------------------------------------------------
  'pt': unitWrap(5.68e-4, {
    m: 3
  }),
  // pint (imperial)
  'qt': unitWrap(1.13652e-3, {
    m: 3
  }),
  // quart (imperial)
  'gal': unitWrap(4.54609e-3, {
    m: 3
  }),
  // gallon (imperial)
  'pt_l': unitWrap(4.73e-4, {
    m: 3
  }),
  // pint (US liquid)
  'qt_l': unitWrap(9.46e-4, {
    m: 3
  }),
  // quart (US liquid)
  'gal_l': unitWrap(3.785e-3, {
    m: 3
  }),
  // gallon (US liquid)
  'pt_d': unitWrap(5.51e-4, {
    m: 3
  }),
  // pint (US dry)
  'qt_d': unitWrap(1.101e-3, {
    m: 3
  }),
  // quart (US dry)
  'gal_d': unitWrap(4.405e-3, {
    m: 3
  }),
  // gallon (US dry)
  // ========================================================================
  // Mass
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'ng': unitWrap(1e-12, {
    kg: 1
  }),
  // nanogram
  'μg': unitWrap(1e-9, {
    kg: 1
  }),
  // microgram
  'mg': unitWrap(1e-6, {
    kg: 1
  }),
  // milligram
  'g': unitWrap(1e-3, {
    kg: 1
  }),
  // gram
  'kg': unitWrap(1e0, {
    kg: 1
  }),
  // kilogram (base unit)
  'Mg': unitWrap(1e3, {
    kg: 1
  }),
  // megagram
  'Gg': unitWrap(1e6, {
    kg: 1
  }),
  // gigagram
  't': unitWrap(1e3, {
    kg: 1
  }),
  // tonne (metric ton)
  'u': unitWrap(1.660539e-27, {
    kg: 1
  }),
  // unified atomic mass unit
  'Da': unitWrap(1.660539e-27, {
    kg: 1
  }),
  // dalton
  // Imperial ---------------------------------------------------------------
  'oz': unitWrap(2.83495e-3, {
    kg: 1
  }),
  // ounce
  'lb': unitWrap(0.453592, {
    kg: 1
  }),
  // pound
  'st': unitWrap(6.350293, {
    kg: 1
  }),
  // stone
  'ton': unitWrap(1.0160e3, {
    kg: 1
  }),
  // ton
  // ========================================================================
  // Time
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'as': unitWrap(1e-18, {
    s: 1
  }),
  // attosecond
  'fs': unitWrap(1e-15, {
    s: 1
  }),
  // femtosecond
  'ps': unitWrap(1e-12, {
    s: 1
  }),
  // picosecond
  'ns': unitWrap(1e-9, {
    s: 1
  }),
  // nanosecond
  'μs': unitWrap(1e-6, {
    s: 1
  }),
  // microsecond
  'ms': unitWrap(1e-3, {
    s: 1
  }),
  // millisecond
  's': unitWrap(1e0, {
    s: 1
  }),
  // second (base unit)
  // Others -----------------------------------------------------------------
  'min': unitWrap(60, {
    s: 1
  }),
  // minute
  'h': unitWrap(3600, {
    s: 1
  }),
  // hour
  'hr': unitWrap(3600, {
    s: 1
  }),
  // hour
  'd': unitWrap(86400, {
    s: 1
  }),
  // day
  'day': unitWrap(86400, {
    s: 1
  }),
  // day
  'y': unitWrap(31557600, {
    s: 1
  }),
  // year (Julian, 365.25 days)
  'yr': unitWrap(31557600, {
    s: 1
  }),
  // year (Julian, 365.25 days)
  // ========================================================================
  // Frequency
  // ========================================================================
  'nHz': unitWrap(1e-9, {
    s: -1
  }),
  // nanohertz
  'μHz': unitWrap(1e-6, {
    s: -1
  }),
  // microhertz
  'mHz': unitWrap(1e-3, {
    s: -1
  }),
  // millihertz
  'Hz': unitWrap(1e0, {
    s: -1
  }),
  // hertz
  'kHz': unitWrap(1e3, {
    s: -1
  }),
  // kilohertz
  'MHz': unitWrap(1e6, {
    s: -1
  }),
  // megahertz
  'GHz': unitWrap(1e9, {
    s: -1
  }),
  // gigahertz
  'THz': unitWrap(1e12, {
    s: -1
  }),
  // terahertz
  'PHz': unitWrap(1e15, {
    s: -1
  }),
  // petahertz
  // ========================================================================
  // Angle
  // ========================================================================
  'rad': valueWrap(1),
  // radian
  'sr': valueWrap(1),
  // steradian
  'deg': valueWrap(0.01745329252),
  // degree
  '°': valueWrap(0.01745329252),
  // degree (symbol)
  // ========================================================================
  // Ratio
  // ========================================================================
  '%': valueWrap(0.01),
  // percent
  '‰': valueWrap(0.001),
  // permille
  // ========================================================================
  // Temperature
  // ========================================================================
  'K': unitWrap(1, {
    K: 1
  }),
  // Kelvin (base unit)
  '°C': unitWrap(1, {
    K: 1
  }),
  // degree Celcius
  '°F': unitWrap(0.555556, {
    K: 1
  }),
  // degree Fahrenheit
  '°R': unitWrap(0.555556, {
    K: 1
  }),
  // degree Rankine
  // Offsets ----------------------------------------------------------------
  '°C_0': unitWrap(273.15, {
    K: 1
  }),
  // degree Celcius offset from absolute zero
  '°F_0': unitWrap(255.372, {
    K: 1
  }),
  // degree Fahrenheit offset from absolute zero
  // ========================================================================
  // Speed
  // ========================================================================
  'kph': unitWrap(0.27778, {
    m: 1,
    s: -1
  }),
  // kilometers per hour
  'mph': unitWrap(0.44704, {
    m: 1,
    s: -1
  }),
  // miles per hour
  'kn': unitWrap(0.514444, {
    m: 1,
    s: -1
  }),
  // knot, nautical mile per hour
  'c': unitWrap(299792458, {
    m: 1,
    s: -1
  }),
  // Speed of light in vacuum
  // ========================================================================
  // Acceperation
  // ========================================================================
  'g_0': unitWrap(9.80665, {
    m: 1,
    s: -2
  }),
  // gravity of Earth
  // ========================================================================
  // Force
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'nN': unitWrap(1e-9, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // nanonewton
  'μN': unitWrap(1e-6, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // micronewton
  'mN': unitWrap(1e-3, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // millinewton
  'N': unitWrap(1e0, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // newton
  'kN': unitWrap(1e3, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // kilonewton
  'MN': unitWrap(1e6, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // meganewton
  'GN': unitWrap(1e9, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // giganewton
  // Imperial ---------------------------------------------------------------
  'ozf': unitWrap(0.278014, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // ounce force
  'lbf': unitWrap(4.448222, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // pound force
  // Others -----------------------------------------------------------------
  'kgf': unitWrap(9.80665, {
    kg: 1,
    m: 1,
    s: -2
  }),
  // kilogram force
  // ========================================================================
  // Energy
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'nJ': unitWrap(1e-9, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // nanojoule
  'μJ': unitWrap(1e-6, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // microjoule
  'mJ': unitWrap(1e-3, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // millijoule
  'J': unitWrap(1e0, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // joule
  'kJ': unitWrap(1e3, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // kilojoule
  'MJ': unitWrap(1e6, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // megajoule
  'GJ': unitWrap(1e9, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // gigajoule
  'TJ': unitWrap(1e12, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // terajoule
  'PJ': unitWrap(1e15, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // petajoule
  // Others -----------------------------------------------------------------
  'cal': unitWrap(4.1868, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // calorie
  'kcal': unitWrap(4186.8, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // kilocalorie
  'Cal': unitWrap(4186.8, {
    kg: 1,
    m: 2,
    s: -2
  }),
  // kilocalorie
  // ========================================================================
  // Power
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'nW': unitWrap(1e-9, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // nanowatt
  'μW': unitWrap(1e-6, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // microwatt
  'mW': unitWrap(1e-3, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // milliwatt
  'W': unitWrap(1e0, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // watt
  'kW': unitWrap(1e3, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // kilowatt
  'MW': unitWrap(1e6, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // megawatt
  'GW': unitWrap(1e9, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // gigawatt
  'TW': unitWrap(1e12, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // terawatt
  'PW': unitWrap(1e15, {
    kg: 1,
    m: 2,
    s: -3
  }),
  // petawatt
  // ========================================================================
  // Pressure
  // ========================================================================
  // SI ---------------------------------------------------------------------
  'nPa': unitWrap(1e-9, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // nanopascal
  'μPa': unitWrap(1e-6, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // micropascal
  'mPa': unitWrap(1e-3, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // millipascal
  'Pa': unitWrap(1e0, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // pascal
  'kPa': unitWrap(1e3, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // kilopascal
  'MPa': unitWrap(1e6, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // megapascal
  'GPa': unitWrap(1e9, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // gigapascal
  'TPa': unitWrap(1e12, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // terapascal
  'PPa': unitWrap(1e15, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // petapascal
  // Imperial ---------------------------------------------------------------
  'psi': unitWrap(6.89475729e3, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // pounds per square inch
  // Others -----------------------------------------------------------------
  'atm': unitWrap(1.01325e5, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // standard atmosphere
  'bar': unitWrap(1e5, {
    kg: 1,
    m: -1,
    s: -2
  }),
  // bar
  // ========================================================================
  // Amount of substance
  // ========================================================================
  'nmol': unitWrap(1e-9, {
    mol: 1
  }),
  // nanomole
  'μmol': unitWrap(1e-6, {
    mol: 1
  }),
  // micromole
  'mmol': unitWrap(1e-3, {
    mol: 1
  }),
  // millimole
  'mol': unitWrap(1e0, {
    mol: 1
  }),
  // mole (base unit)
  'kmol': unitWrap(1e3, {
    mol: 1
  }),
  // kilomole
  'Mmol': unitWrap(1e6, {
    mol: 1
  }),
  // megamole
  'Gmol': unitWrap(1e9, {
    mol: 1
  }),
  // gigamole
  'Tmol': unitWrap(1e12, {
    mol: 1
  }),
  // teramole
  'Pmol': unitWrap(1e15, {
    mol: 1
  }),
  // petamole
  // Related ----------------------------------------------------------------
  'N_A': unitWrap(6.022140857e23, {
    mol: -1
  }),
  // Avogadro constant
  // ========================================================================
  // Luminous intensity
  // ========================================================================
  'ncd': unitWrap(1e-9, {
    cd: 1
  }),
  // nanocandela
  'μcd': unitWrap(1e-6, {
    cd: 1
  }),
  // microcandela
  'mcd': unitWrap(1e-3, {
    cd: 1
  }),
  // millicandela
  'cd': unitWrap(1e0, {
    cd: 1
  }),
  // candela (base unit)
  'kcd': unitWrap(1e3, {
    cd: 1
  }),
  // kilocandela
  'Mcd': unitWrap(1e6, {
    cd: 1
  }),
  // megacandela
  'Gcd': unitWrap(1e9, {
    cd: 1
  }),
  // gigacandela
  'Tcd': unitWrap(1e12, {
    cd: 1
  }),
  // teracandela
  'Pcd': unitWrap(1e15, {
    cd: 1
  }),
  // petacandela
  // ========================================================================
  // Luminous flux
  // ========================================================================
  'nlm': unitWrap(1e-9, {
    cd: 1
  }),
  // nanolumen
  'μlm': unitWrap(1e-6, {
    cd: 1
  }),
  // microlumen
  'mlm': unitWrap(1e-3, {
    cd: 1
  }),
  // millilumen
  'lm': unitWrap(1e0, {
    cd: 1
  }),
  // lumen
  'klm': unitWrap(1e3, {
    cd: 1
  }),
  // kilolumen
  'Mlm': unitWrap(1e6, {
    cd: 1
  }),
  // megalumen
  'Glm': unitWrap(1e9, {
    cd: 1
  }),
  // gigalumen
  'Tlm': unitWrap(1e12, {
    cd: 1
  }),
  // teralumen
  'Plm': unitWrap(1e15, {
    cd: 1
  }),
  // petalumen
  // ========================================================================
  // Illuminance
  // ========================================================================
  'nlx': unitWrap(1e-9, {
    cd: 1,
    m: -2
  }),
  // nanolux
  'μlx': unitWrap(1e-6, {
    cd: 1,
    m: -2
  }),
  // microlux
  'mlx': unitWrap(1e-3, {
    cd: 1,
    m: -2
  }),
  // millilux
  'lx': unitWrap(1e0, {
    cd: 1,
    m: -2
  }),
  // lux
  'klx': unitWrap(1e3, {
    cd: 1,
    m: -2
  }),
  // kilolux
  'Mlx': unitWrap(1e6, {
    cd: 1,
    m: -2
  }),
  // megalux
  'Glx': unitWrap(1e9, {
    cd: 1,
    m: -2
  }),
  // gigalux
  'Tlx': unitWrap(1e12, {
    cd: 1,
    m: -2
  }),
  // teralux
  'Plx': unitWrap(1e15, {
    cd: 1,
    m: -2
  }),
  // petalux
  // ========================================================================
  // Current
  // ========================================================================
  'nA': unitWrap(1e-9, {
    A: 1
  }),
  // nanoampere
  'μA': unitWrap(1e-6, {
    A: 1
  }),
  // microampere
  'mA': unitWrap(1e-3, {
    A: 1
  }),
  // milliampere
  'A': unitWrap(1e0, {
    A: 1
  }),
  // ampere (base unit)
  'kA': unitWrap(1e3, {
    A: 1
  }),
  // kiloampere
  'MA': unitWrap(1e6, {
    A: 1
  }),
  // megaampere
  'GA': unitWrap(1e9, {
    A: 1
  }),
  // gigaampere
  'TA': unitWrap(1e12, {
    A: 1
  }),
  // teraampere
  'PA': unitWrap(1e15, {
    A: 1
  }),
  // petaampere
  // ========================================================================
  // Charge
  // ========================================================================
  'nC': unitWrap(1e-9, {
    A: 1,
    s: 1
  }),
  // nanocoulomb
  'μC': unitWrap(1e-6, {
    A: 1,
    s: 1
  }),
  // microcoulomb
  'mC': unitWrap(1e-3, {
    A: 1,
    s: 1
  }),
  // millicoulomb
  'C': unitWrap(1e0, {
    A: 1,
    s: 1
  }),
  // coulomb
  'kC': unitWrap(1e3, {
    A: 1,
    s: 1
  }),
  // kilocoulomb
  'MC': unitWrap(1e6, {
    A: 1,
    s: 1
  }),
  // megacoulomb
  'GC': unitWrap(1e9, {
    A: 1,
    s: 1
  }),
  // gigacoulomb
  'TC': unitWrap(1e12, {
    A: 1,
    s: 1
  }),
  // teracoulomb
  'PC': unitWrap(1e15, {
    A: 1,
    s: 1
  }),
  // petacoulomb
  // ========================================================================
  // Voltage
  // ========================================================================
  'nV': unitWrap(1e-9, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // nanovolt
  'μV': unitWrap(1e-6, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // microvolt
  'mV': unitWrap(1e-3, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // millivolt
  'V': unitWrap(1e0, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // volt
  'kV': unitWrap(1e3, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // kilovolt
  'MV': unitWrap(1e6, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // megavolt
  'GV': unitWrap(1e9, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // gigavolt
  'TV': unitWrap(1e12, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // teravolt
  'PV': unitWrap(1e15, {
    kg: 1,
    m: 2,
    s: -3,
    A: -1
  }),
  // petavolt
  // ========================================================================
  // Capacitance
  // ========================================================================
  'nF': unitWrap(1e-9, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // nanofarad
  'μF': unitWrap(1e-6, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // microfarad
  'mF': unitWrap(1e-3, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // millifarad
  'F': unitWrap(1e0, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // farad
  'kF': unitWrap(1e3, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // kilofarad
  'MF': unitWrap(1e6, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // megafarad
  'GF': unitWrap(1e9, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // gigafarad
  'TF': unitWrap(1e12, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // terafarad
  'PF': unitWrap(1e15, {
    kg: -1,
    m: -2,
    s: 4,
    A: 2
  }),
  // petafarad
  // ========================================================================
  // Resistance
  // ========================================================================
  'nΩ': unitWrap(1e-9, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // nanoohm
  'μΩ': unitWrap(1e-6, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // microohm
  'mΩ': unitWrap(1e-3, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // milliohm
  'Ω': unitWrap(1e0, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // ohm
  'kΩ': unitWrap(1e3, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // kiloohm
  'MΩ': unitWrap(1e6, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // megaohm
  'GΩ': unitWrap(1e9, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // gigaohm
  'TΩ': unitWrap(1e12, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // teraohm
  'PΩ': unitWrap(1e15, {
    kg: 1,
    m: 2,
    s: -3,
    A: -2
  }),
  // petaohm
  // ========================================================================
  // Resistance
  // ========================================================================
  'nS': unitWrap(1e-9, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // nanosiemens
  'μS': unitWrap(1e-6, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // microsiemens
  'mS': unitWrap(1e-3, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // millisiemens
  'S': unitWrap(1e0, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // siemens
  'kS': unitWrap(1e3, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // kilosiemens
  'MS': unitWrap(1e6, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // megasiemens
  'GS': unitWrap(1e9, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // gigasiemens
  'TS': unitWrap(1e12, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // terasiemens
  'PS': unitWrap(1e15, {
    kg: -1,
    m: -2,
    s: 3,
    A: 2
  }),
  // petasiemens
  // ========================================================================
  // Magnetic flux
  // ========================================================================
  'nWb': unitWrap(1e-9, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // nanoweber
  'μWb': unitWrap(1e-6, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // microweber
  'mWb': unitWrap(1e-3, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // milliweber
  'Wb': unitWrap(1e0, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // weber
  'kWb': unitWrap(1e3, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // kiloweber
  'MWb': unitWrap(1e6, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // megaweber
  'GWb': unitWrap(1e9, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // gigaweber
  'TWb': unitWrap(1e12, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // teraweber
  'PWb': unitWrap(1e15, {
    kg: 1,
    m: 2,
    s: -2,
    A: -1
  }),
  // petaweber
  // ========================================================================
  // Magnetic flux density
  // ========================================================================
  'nT': unitWrap(1e-9, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // nanotesla
  'μT': unitWrap(1e-6, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // microtesla
  'mT': unitWrap(1e-3, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // millitesla
  'T': unitWrap(1e0, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // tesla
  'kT': unitWrap(1e3, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // kilotesla
  'MT': unitWrap(1e6, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // megatesla
  'GT': unitWrap(1e9, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // gigatesla
  'TT': unitWrap(1e12, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // teratesla
  'PT': unitWrap(1e15, {
    kg: 1,
    s: -2,
    A: -1
  }),
  // petatesla
  // ========================================================================
  // Magnetic flux
  // ========================================================================
  'nH': unitWrap(1e-9, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // nanohenry
  'μH': unitWrap(1e-6, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // microhenry
  'mH': unitWrap(1e-3, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // millihenry
  'H': unitWrap(1e0, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // henry
  'kH': unitWrap(1e3, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // kilohenry
  'MH': unitWrap(1e6, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // megahenry
  'GH': unitWrap(1e9, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // gigahenry
  'TH': unitWrap(1e12, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // terahenry
  'PH': unitWrap(1e15, {
    kg: 1,
    m: 2,
    s: -2,
    A: -2
  }),
  // petahenry
  // ========================================================================
  // Radioactivity (decays per unit of time)
  // ========================================================================
  'nBq': unitWrap(1e-9, {
    s: -1
  }),
  // nanobecquerel
  'μBq': unitWrap(1e-6, {
    s: -1
  }),
  // microbecquerel
  'mBq': unitWrap(1e-3, {
    s: -1
  }),
  // millibecquerel
  'Bq': unitWrap(1e0, {
    s: -1
  }),
  // becquerel
  'kBq': unitWrap(1e3, {
    s: -1
  }),
  // kilobecquerel
  'MBq': unitWrap(1e6, {
    s: -1
  }),
  // megabecquerel
  'GBq': unitWrap(1e9, {
    s: -1
  }),
  // gigabecquerel
  'TBq': unitWrap(1e12, {
    s: -1
  }),
  // terabecquerel
  'PBq': unitWrap(1e15, {
    s: -1
  }),
  // petabecquerel
  // ========================================================================
  // Absorbed dose
  // ========================================================================
  'nGy': unitWrap(1e-9, {
    m: 2,
    s: -2
  }),
  // nanogray
  'μGy': unitWrap(1e-6, {
    m: 2,
    s: -2
  }),
  // microgray
  'mGy': unitWrap(1e-3, {
    m: 2,
    s: -2
  }),
  // milligray
  'Gy': unitWrap(1e0, {
    m: 2,
    s: -2
  }),
  // gray
  'kGy': unitWrap(1e3, {
    m: 2,
    s: -2
  }),
  // kilogray
  'MGy': unitWrap(1e6, {
    m: 2,
    s: -2
  }),
  // megagray
  'GGy': unitWrap(1e9, {
    m: 2,
    s: -2
  }),
  // gigagray
  'TGy': unitWrap(1e12, {
    m: 2,
    s: -2
  }),
  // teragray
  'PGy': unitWrap(1e15, {
    m: 2,
    s: -2
  }),
  // petagray
  // ========================================================================
  // Equivalent dose
  // ========================================================================
  'nSv': unitWrap(1e-9, {
    m: 2,
    s: -2
  }),
  // nanosievert
  'μSv': unitWrap(1e-6, {
    m: 2,
    s: -2
  }),
  // microsievert
  'mSv': unitWrap(1e-3, {
    m: 2,
    s: -2
  }),
  // millisievert
  'Sv': unitWrap(1e0, {
    m: 2,
    s: -2
  }),
  // sievert
  'kSv': unitWrap(1e3, {
    m: 2,
    s: -2
  }),
  // kilosievert
  'MSv': unitWrap(1e6, {
    m: 2,
    s: -2
  }),
  // megasievert
  'GSv': unitWrap(1e9, {
    m: 2,
    s: -2
  }),
  // gigasievert
  'TSv': unitWrap(1e12, {
    m: 2,
    s: -2
  }),
  // terasievert
  'PSv': unitWrap(1e15, {
    m: 2,
    s: -2
  }),
  // petasievert
  // ========================================================================
  // Data
  // ========================================================================
  'bit': unitWrap(1, {
    bit: 1
  }),
  // bit
  'B': unitWrap(8, {
    bit: 1
  }),
  // byte
  // Decimal bit (bit per IEC 60027) ----------------------------------------
  'kbit': unitWrap(1e3, {
    bit: 1
  }),
  // kilobit
  'Mbit': unitWrap(1e6, {
    bit: 1
  }),
  // megabit
  'Gbit': unitWrap(1e9, {
    bit: 1
  }),
  // gigabit
  'Tbit': unitWrap(1e12, {
    bit: 1
  }),
  // terabit
  'Pbit': unitWrap(1e15, {
    bit: 1
  }),
  // petabit
  'Ebit': unitWrap(1e18, {
    bit: 1
  }),
  // exabit
  'Zbit': unitWrap(1e21, {
    bit: 1
  }),
  // zettabit
  'Ybit': unitWrap(1e24, {
    bit: 1
  }),
  // yottabit
  // Binary bit (bit per IEC 60027) -----------------------------------------
  'Kibit': unitWrap(1024, {
    bit: 1
  }),
  // kilobit
  'Mibit': unitWrap(1048576, {
    bit: 1
  }),
  // megabit
  'Gibit': unitWrap(107374182, {
    bit: 1
  }),
  // gigabit
  'Tibit': unitWrap(1099511627776, {
    bit: 1
  }),
  // terabit
  'Pibit': unitWrap(1125899906842624, {
    bit: 1
  }),
  // petabit
  'Eibit': unitWrap(1152921504606847000, {
    bit: 1
  }),
  // exabit
  'Zibit': unitWrap(1180591620717411303424, {
    bit: 1
  }),
  // zettabit
  'Yibit': unitWrap(1208925819614629174706176, {
    bit: 1
  }),
  // yottabit
  // Decimal bit (b per IEEE 1541 Standard) ---------------------------------
  'kb': unitWrap(1e3, {
    bit: 1
  }),
  // kilobit
  'Mb': unitWrap(1e6, {
    bit: 1
  }),
  // megabit
  'Gb': unitWrap(1e9, {
    bit: 1
  }),
  // gigabit
  'Tb': unitWrap(1e12, {
    bit: 1
  }),
  // terabit
  'Pb': unitWrap(1e15, {
    bit: 1
  }),
  // petabit
  'Eb': unitWrap(1e18, {
    bit: 1
  }),
  // exabit
  'Zb': unitWrap(1e21, {
    bit: 1
  }),
  // zettabit
  'Yb': unitWrap(1e24, {
    bit: 1
  }),
  // yottabit
  // Binary bit (b per IEEE 1541 Standard) ----------------------------------
  'Kib': unitWrap(1024, {
    bit: 1
  }),
  // kilobit
  'Mib': unitWrap(1048576, {
    bit: 1
  }),
  // megabit
  'Gib': unitWrap(107374182, {
    bit: 1
  }),
  // gigabit
  'Tib': unitWrap(1099511627776, {
    bit: 1
  }),
  // terabit
  'Pib': unitWrap(1125899906842624, {
    bit: 1
  }),
  // petabit
  'Eib': unitWrap(1152921504606847000, {
    bit: 1
  }),
  // exabit
  'Zib': unitWrap(1180591620717411303424, {
    bit: 1
  }),
  // zettabit
  'Yib': unitWrap(1208925819614629174706176, {
    bit: 1
  }),
  // yottabit
  // Decimal byte -----------------------------------------------------------
  'kB': unitWrap(8e3, {
    bit: 1
  }),
  // kilobyte
  'MB': unitWrap(8e6, {
    bit: 1
  }),
  // megabyte
  'GB': unitWrap(8e9, {
    bit: 1
  }),
  // gigabyte
  'TB': unitWrap(8e12, {
    bit: 1
  }),
  // terabyte
  'PB': unitWrap(8e15, {
    bit: 1
  }),
  // petabyte
  'EB': unitWrap(8e18, {
    bit: 1
  }),
  // exabyte
  'ZB': unitWrap(8e21, {
    bit: 1
  }),
  // zettabyte
  'YB': unitWrap(8e24, {
    bit: 1
  }),
  // yottabyte
  // Binary byte ------------------------------------------------------------
  'KiB': unitWrap(8192, {
    bit: 1
  }),
  // kilobyte
  'MiB': unitWrap(8388608, {
    bit: 1
  }),
  // megabyte
  'GiB': unitWrap(8589934592, {
    bit: 1
  }),
  // gigabyte
  'TiB': unitWrap(8796093022208, {
    bit: 1
  }),
  // terabyte
  'PiB': unitWrap(9007199254740992, {
    bit: 1
  }),
  // petabyte
  'EiB': unitWrap(9223372036854776000, {
    bit: 1
  }),
  // exabyte
  'ZiB': unitWrap(9444732965739290427392, {
    bit: 1
  }),
  // zettabyte
  'YiB': unitWrap(9671406556917033397649408, {
    bit: 1
  }),
  // yottabyte
  // ========================================================================
  // Miscellaneous
  // ========================================================================
  'G': unitWrap(6.67408e-11, {
    m: 3,
    kg: -1,
    s: -2
  }) // Gravitational constant

};

function unitWrap(value, units) {
  return {
    type: 'unit',
    units: units,
    value: valueWrap(value)
  };
}

exports.createResolverFunction = createResolverFunction;
exports.defaultFunctions = defaultFunctions;
exports.defaultVariables = defaultVariables;
exports.format = format;
exports.resolve = resolve;
